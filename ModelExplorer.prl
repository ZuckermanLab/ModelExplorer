#!/usr/bin/perl -w
use PDL; #Using PDL to solve matrix in perl - AG 2017
use JSON;
use utf8;
use warnings;
use Data::Dumper; #helpful for debugging
use Config::Simple;
use List::Util qw(first);
use File::Copy qw(copy);
use Cwd qw(chdir);
use Storable qw(dclone);
use Win32; # for error popup dialog
use Chart::Gnuplot;
use Try::Tiny;
#use Math::MatrixReal;

#use strict; #errors out

# Monte Carlo program to explore 'model space' by using steady-state transport
# properties as MC 'energy'.
# Written by DM Zuckerman 2016-17
# Additional updates by August George 2017-18
# Please see README for more information

# This program has had limited testing. USE AT YOUR OWN RISK!

# IN PROGRESS:
# update pipeline/automation

# BUGS:
#"use strict" errors out... "Variable name" requires explicit package name.

# USAGE:
# Use config file to set parameters (listed near bottom of code)
# run in command line using ./ModelExplorer.prl > log
# In addition to screen ouput (which can be re-directed to log file) several files are
# generated automatically.
# For basic analysis, plot MC energy vs step number: first two columns of evolver_rates.dat,
# which is one of the output files. Negative energies correspond to "successful" models
# given by the energy function.
# This program also uses a python script to check for network consistency

# TOP TO-DO (see full list in readme):
# Improve program performance (distance subroutine botleneck, PDL matrix solver)
# Improve documentation (code comments and readme)
# Rewrite code into subroutines
# Use config file (DONE)
# Add unit tests (In Progress)

# UNIT TESTS TO ADD:
# (1) Sum of steady state probabilities is one (DONE)
# (2) Ratio of rates for a state pair give Boltz fac of energy difference
# (3) Energy differences among tied states match constraints
# (4) Energies of fixed states remain at constrained values
# (5) Reject/Restore step properly restores energies (DONE)
# (6) Tied states graphs are self-consistent (DONE)

# To get estimated runtime
my $start_time = time(); # for basic runtime
#print LOG "\n\nstart time: $start_time\n\n";


#################### CONFIGURATION ####################
my $config_path = "config.txt";
%parameters = load_config_settings($config_path);

#non ideal solution to use config file with existing code... (prexisting parameters set to hash values loaded from config file)
$proof = $parameters{"proof"}; # 1 if proofreading (additional states and transitions present compared to simple transport)
$na_first = $parameters{"na_first"}; # 1 if 'sodium' (N) is forced to bind first
$nsteps = $parameters{"nsteps"}; # number of Monte Carlo steps
$dprint = $parameters{"dprint"}; # interval between prints
$n_beta = $parameters{"n_beta"}; # number of MC steps after which beta (inverse temperature) changes
$seed = $parameters{"seed"}; # seed for random number generator
$demax = $parameters{"demax"}; # maximum change in energy of state or transition state
$alpha = $parameters{"alpha"}; # exponent for toxin flow in MC 'energy' function which sets fitness of model
$temp_scale = $parameters{"temp_scale"}; # scaling factor for tempering schedule (>1 stretches, <1 shrinks)

#$beta_init = $parameters{"beta_init"}; # initial value of beta = inverse temperature
#$beta = $beta_init;
$b_min= $parameters{"b_min"}; #
$beta = $b_min;
$b_max= $parameters{"b_max"}; #
#$b_steps = $parameters{"b_steps"}; #
#$fbeta = $parameters{"fbeta"}; # max factor by which beta can change during the MC run, which includes 'tempering'
$tol = $parameters{"tol"}; # fractional energy change deemed significant in tempering
$pbeta_stay = $parameters{"pbeta_stay"}; # probability to stay at same beta during tempering
$dmu_N = $parameters{"dmu_N"}; # chemical potential change (mu_i - mu_o) of driving "ion" N (e.g., sodium)
$dmu_S = $parameters{"dmu_S"}; # chemical potential change of "substrate" S (e.g., sugar)
$dmu_W = $parameters{"dmu_W"}; # chemical potential change of wrong "substrate" W (e.g., toxin)
$fmu_N = $parameters{"fmu_N"}; # fraction of dmu attributed to outside - i.e., log of concentration increase relative to equil
$fmu_S = $parameters{"fmu_S"}; # fraction of dmu attributed to outside - i.e., log of concentration increase relative to equil
$fmu_W = $parameters{"fmu_W"}; # fraction of dmu attributed to outside - i.e., log of concentration increase relative to equil
$ebarslow = $parameters{"ebarslow"}; # minimum energy value of barrier height (above max of two states) for slow transitions
$kzero = $parameters{"kzero"}; # rate constant prefactor: full first-order rate constant = k_ij = kzero * exp( - barrier_energy )
$ebump = $parameters{"ebump"};  # amount by which initial transition-state (barrier) energy exceeds max of pair

$directory = $parameters{"directory"}; # path for run drectory
$tmpfile = $parameters{"tmpfile"}; # temporary file used for calculations
$mcfile = $parameters{"mcfile"}; # outputs monte carlo information
$kfile = $parameters{"kfile"}; # temporary file which contains rate matrix
$datfile = $parameters{"datfile"}; # outputs MC number and MC energy function. USE FOR BASIC ANALYSIS!
$flowfile = $parameters{"flowfile"}; #temporary file whihc contains configuration states for trial pertubation
$debugfile = $parameters{"debugfile"}; # outputs debug info (as needed)
#$logfile = $parameters{"logfile"}; # console output to log file
#$autobot = $parameters{"autobot"}; # turn on/off automation (default = 0 = OFF), currently disabled
$dg_sw_config = $parameters{"dg_sw"};
$dg_SW = $dg_sw_config; # amount by which binding energy of W exceeds that of S
$Sb_Wb_tied = $parameters{"Sb_Wb_tied"}; #controls how "tied" Sb and Wb barriers are ...
#... 0: No tied barriers, ...
#... 1: S (un)binding barriers = W (un)binding barrers (i.e. So->Sb = Wo->Wb), ...
#... 2: Transition w/ Sb state = Transition w/ Wb state (i.e. OF-Sb->IF-Sb = OF-Wb->IF-Wb), ...
#... 3: both 1 and 2
$energy_function = $parameters{"energy_function"};

#$graph = $parameters{"graph"}; #turns on MC trajectory graphing
if ( $proof!=1 ) { #if proof reading is turned off, there is no 'W'
  $Sb_Wb_tied =0;
  $dg_SW = 0;
}

srand($seed); # initializes random number generator ... should make MC repeatable
#$dfactor = 1e0; #$nsteps/100; #testing, don't make energy files for every n value...
#create new directory for this run to store files
unless(-e $directory or mkdir $directory) { #make directory if directory does not already exist
        die "Unable to create $directory\n";
    }



my $pythonfile = "cycle_checker.py"; #creates equivalient states/transitions
my $analyze_script = "ModelAnalyzer.prl"; #analyzers by sweeping dmu
my $analysis_config = "analysis_config.txt"; #configures analysis
my $python_analysis = "flux_grapher.py"; #loads and creates pathway graphs
my $clusterfile = "cluster_data.dat";
#my $find_min_script = "find_min.py"; #automation diasbled for now

#new directory location
my $pythonfilenew = $directory."\/".$pythonfile;
my $config_path_new = $directory."\/".$config_path;
my $analyze_script_new = $directory."\/".$analyze_script;
my $python_analysis_new = $directory."\/".$python_analysis;
my $analysis_config_new = $directory."\/".$analysis_config;
#my $find_min_script_new = $directory."\/".$find_min_script;#automation diasbled for now

#copy files to new directory
copy $pythonfile, $pythonfilenew; #copy python script into new folder
copy $config_path, $config_path_new;
copy $analyze_script, $analyze_script_new;
copy $python_analysis, $python_analysis_new;
copy $analysis_config, $analysis_config_new;
#copy $find_min_script, $find_min_script_new; #automation diasbled for now

chdir("$directory") or die "Error! Cannot change working directory: $!\n"; #change working directory


my $logfile = "datalog"; #make datalog
open(LOG, "> $logfile") or die "Error! Cannot open $logfile";

open(MCFILE, "> $mcfile") or die "Error! Cannot open $mcfile";
open(DATA, "> $datfile") or die "Error! Cannot open $datfile";
open(FLOWS, "> $flowfile") or die "Error! Cannot open $flowfile";
open(DEBUG, "> $debugfile") or die "Error! Cannot open $debugfile";
open(CLUSTER, "> $clusterfile") or die "Error! Cannot open $debugfile";
open(BETA, "> beta.dat") or die "Error! Cannot open beta file";
open(BETAG, "> beta2.dat") or die "Error! Cannot open beta2 file";


# Simulation Configuration print out
print LOG "Simulation type: proof = $proof  na_first = $na_first Sb_Wb_tied = $Sb_Wb_tied energy_function = $energy_function\n";
print LOG "MC Protocol: Now using flow sflow* |sflow| + epsilon / |wflow| + epsilon **alpha\n";
print LOG "MC Parameters: $nsteps steps    seed = $seed    demax = $demax    alpha = $alpha\n";
#printf LOG "MC Parameters: beta_init (b_min) = %4.1e    max beta factor (not used) = %4.1e    adjusts every %d MC steps\n\n", $b_min, $fbeta, $n_beta;
print LOG "MC Parameters: adjust beta every $n_beta steps\n";
printf LOG "MC Parameters: b_min = $b_min   b_max = $b_max  n\n";
print LOG "MC Parameters: pbeta_stay = $pbeta_stay    tol = $tol\n";
#printf LOG "MC Parameters: beta_early = %4.1e    beta_late = %4.1e   alternates every %d MC steps\n\n", $beta_early, $beta_late, $n_beta;
print LOG "Physical params: dmu_N = $dmu_N    dmu_S = $dmu_S    dmu_W = $dmu_W    ebarslow = $ebarslow    kzero = $kzero    ebump = $ebump";
print LOG "\nPhysical params: fmu_N = $fmu_N    fmu_S = $fmu_S    fmu_W = $fmu_W ";
if ( $proof==1 ) { print LOG "    dg_SW = $dg_SW"; }

print LOG "\n\n";

#################### STATE SPACE CONFIGURATION ####################

# units (cycles) which combinatorially form states: state names fully describe states
@state_bases = ( [ "OF", "IF" ],           # outward facing, inward facing
                 [ "No", "Nb", "Ni" ],     # Na on outside, bound, on inside
                 [ "So", "Sb", "Si" ],     # Sugar on outside, bound, on inside
               );
if ( $proof==1 ) { push @state_bases, [ "Wo", "Wb", "Wi" ]; } #toxin is on outside, bound, on inside

# Information for MC 'energy'/fitness scoring
@goals = ( "Sb", "Si"); # the goal/function is to transition from $goals[0] to $goals[1] - e.g., transport sugar to inside
@ionfwd = ( "Nb", "Ni" ); # the change that leads to ion flow
if ( $proof==1 ) { @not_goals = ( "Wb", "Wi" ); } # do not want to transport toxin!

# Define states of units which are physically equivalent given steady state in which concentrations
# inside and out are held fixed.  So after an ion is transported, the physical state is the same.
@tied_bases = (); # this will be an array of arrays
push @tied_bases, [ "No", "Ni", 0.0 ]; # no longer includes chemical potential info - last entry is dummy
push @tied_bases, [ "So", "Si", 0.0 ];
#push @tied_bases, [ "No", "Ni", $dmu_N ];
#push @tied_bases, [ "So", "Si", $dmu_S ];
if ( $proof==1 ) {
   push @tied_bases, [ "Wo", "Wi", 0.0 ]; # chemical potential info (is dummy entry)
   #push @tied_bases, [ "Wo", "Wi", $dmu_W ]; # chemical potential info
   # Info for fixed relative affinities between S and W
   # Sb states are tied to Wb states to maintain the dg_sw difference between them
   @tied_bases_ne = ();
   push @tied_bases_ne, [ "Sb-Wi", "Si-Wb", $dg_SW ]; #Sb-Wi tied to Si-Wb
   push @tied_bases_ne, [ "Sb-Wo", "So-Wb", $dg_SW ]; #Sb-Wo tied to So-Wb
   push @tied_bases_ne, [ "Sb-Wi", "So-Wb", $dg_SW ]; #Sb-Wi tied to So-Wb
   push @tied_bases_ne, [ "Sb-Wo", "Si-Wb", $dg_SW ]; #Sb-Wo tied to Si-Wb
}


# For proofreading, assume W and S (toxin and substrate) have same energy barrier for (un)binding
# Also assume binding/conf changes w/ Sb are equiv w/ Wb (i.e. OF-No-Sb-Wo -> IF-No-Sb-Wo = OF-No-So-Wb -> IF-No-So-Wb)
if ( $proof == 1 ) {
   @tied_for_bind = ();
   push @tied_for_bind, [ "So-Wo", "So-Wb", "So-Wo", "Sb-Wo" ]; #substrate (un)binding from outside ~ toxin (un)binding from outside
   push @tied_for_bind, [ "Si-Wi", "Si-Wb", "Si-Wi", "Sb-Wi" ]; #substrate (un)binding from inside ~ toxin (un)binding from inside
   @Sb_Wb_tied_list = ();
   push @Sb_Wb_tied_list, [ "Sb-Wo", "So-Wb"]; # OF-No-Sb-Wo -> IF-No-Sb-Wo = OF-No-So-Wb -> IF-No-So-Wb
   push @Sb_Wb_tied_list, [ "Sb-Wo", "Si-Wb"];
   push @Sb_Wb_tied_list, [ "Sb-Wi", "So-Wb"];
   push @Sb_Wb_tied_list, [ "Sb-Wi", "So-Wb"];

}


# Slow transitions - some transitions should be slower than others
# e.g., unbinding to outside from inward-facing (compared to same transition in outward-facing)
@slowies = ();
push @slowies, ["IF", "Nb", "No"]; # b (bound) to i (inside) transition is slow in IF
push @slowies, ["OF", "Nb", "Ni"]; # b (bound) to o (outside) transition is slow in OF
push @slowies, ["IF", "Sb", "So"]; # b (bound) to i (inside) transition is slow in IF
push @slowies, ["OF", "Sb", "Si"]; # b (bound) to o (outside) transition is slow in OF
push @slowies, ["IF", "Wb", "Wo"]; # b (bound) to i (inside) transition is slow in IF
push @slowies, ["OF", "Wb", "Wi"]; # b (bound) to o (outside) transition is slow in OF

# below not used - I made slowies array more specific so subroutine could be simpler
#push @slowies, ["IF", "b", "o"]; # b (bound) to i (inside) transition is slow in IF
#push @slowies, ["OF", "b", "i"]; # b (bound) to o (outside) transition is slow in OF
if ( $na_first==1 ) {
   push @slowies, ["OF", "No-So", "No-Sb"];
   push @slowies, ["OF", "No-Wo", "No-Wb"];
   push @slowies, ["OF", "Ni-So", "Ni-Sb"];
   push @slowies, ["OF", "Ni-Wo", "Ni-Wb"];
}

# Fixed states which cannot change in energy
%fixed_states = (); # hash of states with fixed energy values (to maintain driving)
if ( $proof==1 ) {
   $fixed_states{"OF-No-So-Wo"} = 0.0;  # start/reference state: nothing bound, both outside
}
else { $fixed_states{"OF-No-So"} = 0.0;  } # start/reference state: nothing bound, both outside
## Note that remaining fixed states are fixed based on tied_states machinery


# these are the non-equilibrium energy terms used (ultimately) to adjust rates
# specifically, these terms act as log of concentration difference (vs. equil) to multiply rate const
%energy_terms = ( # amount of energy added per unit for each name
#'OF' => 0.0,
#'IF' => 1.0,
'No' => -$fmu_N*$dmu_N,
'Ni' => (1-$fmu_N)*$dmu_N, # Note that 1 - fmu_N -(-fmu_N) = 1
'So' => -$fmu_S*$dmu_S,
'Si' => (1-$fmu_S)*$dmu_S, # Note that 1 - fmu_S -(-fmu_S) = 1
'Wo' => -$fmu_W*$dmu_W,
'Wi' => (1-$fmu_W)*$dmu_W, # Note that 1 - fmu_W -(-fmu_W) = 1
);

# not used in evolutionary MC
%allostery_terms = ( # additional energy to be added due to combination of events
#'Nb-Sb' => -0.5, # order does not matter
#'Sb-IF' => -1.5
);


# unit combinations to be excluded - e.g., because of mutually exclusive binding
# note that context can be provided by including a conformational state
# note that order does not matter
@exclude = (
             "Sb-Wb" # Sugar and Toxin cannot both be bound!
             #"OF-Ni", "OF-Si" # these will prevent unbinding to inside from OF conformation
             #"Sb-Ni", # means "Sb" and "Ni" cannot occur together in a state
             #"IF-Sb-Nb"
           );


$n_units = @state_bases; # the number of units/modules
print LOG "\nUNITS:\n";
print LOG "Number of units/cycles/modules is $n_units\n\n";

print LOG "These are the elements of the modules:\n";
@unit_lengths = (); # array to be loaded with numbers of sub-states in each unit/module
foreach $x ( @state_bases ) {
   $len = @$x;
   print LOG "Number of elements in unit is: $len\n";
   push @unit_lengths, $len;
   foreach $y (@$x) { print LOG "$y  "; }
   print LOG "\n";
}
print LOG "\n";

print LOG "EXCLUSIONS: The following combinations (in any order) are excluded:\n";
foreach $x (@exclude) { print LOG "$x\n"; }
print LOG "\n";

@states = ();
if ( $n_units==3 ) {
   print LOG "Three modules ... finding states ...\n";
   #print LOG "elements $state_bases[0][0]  $state_bases[0][1]\n";
   $i=0;
   foreach $a ( @{$state_bases[0]} ) {
      $i++; $j=0;
      foreach $b ( @{$state_bases[1]} ) {
         $j++; $k=0;
         foreach $c ( @{$state_bases[2]} ) { # looping over all (trial) states
             $k++;
             $name = "$a-$b-$c";  # trial state to be checked for exclusions
             $check = 0;
             foreach $nonos ( @exclude ) { # $nonos is string containing exclusions
                #print LOG "\n\n checking nono $nonos\n";
                @parts = split /-/, $nonos;
                $test = all_in( \@parts, $name );
                $check += $test; # will exceed zero if any exclusion matches
             }
             #print LOG "$name...parts: @parts     check=$check\n";
             if ( $check==0 ) { # add to states list if not excluded
                push @states, [$name,
                 $i, $j, $k]; # include indices for future distance calculations
             }
             else { print LOG "EXCLUDED CANDIDATE STATE $name\n"; }
         }
      }
   }
}
elsif ( $n_units==4 ) {

   print LOG "Four modules ... finding states ...\n";
   #print LOG "elements $state_bases[0][0]  $state_bases[0][1]\n";
   $i=0;
   foreach $a ( @{$state_bases[0]} ) {
      $i++; $j=0;
      foreach $b ( @{$state_bases[1]} ) {
         $j++; $k=0;
         foreach $c ( @{$state_bases[2]} ) { # looping over all (trial) states
             $k++; $m=0;
             foreach $d ( @{$state_bases[3]} ) { # looping over all (trial) states
                $m++;
                $name = "$a-$b-$c-$d";  # trial state to be checked for exclusions
                $check = 0;
                foreach $nonos ( @exclude ) { # $nonos is string containing exclusions
                   #print LOG "\n\n checking nono $nonos\n";
                   @parts = split /-/, $nonos;
                   $test = all_in( \@parts, $name );
                   $check += $test; # will exceed zero if any exclusion matches
                }
                #print LOG "$name...parts: @parts     check=$check\n";
                if ( $check==0 ) { # add to states list if not excluded
                   push @states, [$name,
                    $i, $j, $k, $m]; # include indices for future distance calculations
                }
                else { print LOG "EXCLUDED CANDIDATE STATE $name\n"; }
            }
         }
      }
   }
}
print LOG "\n";
$nstates = @states;
print LOG "\nConstructed $nstates states\n";

# Create a null adjacent matrix with elements A_ij and states i,j.
# If states are connected then A_ij = A_ji = 1. Else, A_ij = A_ji = 0.
my @state_adjacent_matrix = ();
push @state_adjacent_matrix, [(0)x$nstates] for (1..$nstates);

# Create a null matrix with relative energy difference betwen states i and j.
# i.e. A_ij = E_j - E_i and A_ji = E_i-E_j (which is $etmp and -$etmp respectively)
my @state_relative_energy= ();
push @state_relative_energy, [(0)x$nstates] for (1..$nstates);


# Make energy hash, assign initial energies (all zero except if in fixed list)
# and make hash of state names to indices
@snames = (); # array of state names
%energies = ();
%energies_noneq = ();
%indices = ();
print LOG "\n";
foreach $fixed ( keys %fixed_states ) {
   print LOG "This state is fixed: $fixed with energy $fixed_states{$fixed}\n";
   print LOG "Program now relies primarily on \"tied states\" (fixed relative energies)\n";
}
print LOG "\n";
print LOG "Here are the states and indices:\n";
$i=0;
foreach $state (@states) {
   $name = $$state[0];
   push @snames, $name;
   if ( grep { $name eq $_ } keys %fixed_states ) {
      #print LOG "Fixed: grep found state $name in fixed list\n";
      $state_energy = $fixed_states{$name};
   }
   else { $state_energy = 0; }
   #$state_energy = energy( \@$state );
   $energies{$name} = $state_energy;
   $energies_noneq{$name} = energy_noneq( \@$state );
   $indices{$name} = $i;
   print LOG "State name and indices: @$state   Energy = $state_energy   i=$i   E_noneq = $energies_noneq{$name}\n";
   $i++;
}
print LOG "\n";

# Generate list of tied states - related by fixed energy values
# Relative affinity pairs omitted here to avoid incorrectly making equivalent states
### Algorithm: compare state pairs for differences in tied_bases array
### When a match is found, replace unit name in state name (w/ XX) - what remains at end must match
### Note: $nchange is used to see if two states are equivalent (for binding of the other species)
### (i.e. for OF: NoSiWo->NoSbWo->NoSoWo differs by one "equivalent" unit Ni/No, No/Ni from NiSiWo->NiSbWo->NiSoWo)
@tied_states = ();  # states themselves which are physically equivalent
@tied_states_tr = ();  # states which are physically equivalent for transitions
@tied_energies = (); # energy values relative to arbitrary reference
print LOG "\nGenerating tied states lists\n";
for ( $i=0; $i<$nstates; $i++ ) {
   for ( $j=$i+1; $j<$nstates; $j++ ) {
      $iname = $snames[$i]; $aname = $iname;
      $jname = $snames[$j]; $bname = $jname;
      $etmp = 0;
      $nchange = 0; # counter for number of changes to make identical.
      foreach $list ( @tied_bases ) {
         $uref = $$list[0]; $uto = $$list[1]; $delmu = $$list[2];
         if ( $iname =~ /$uref/ && $jname =~ /$uto/ ) {
            $etmp += $delmu;
            $iname =~ s/$uref/XX/;
            $jname =~ s/$uto/XX/;
            $nchange ++ ;
         }
         elsif ( $jname =~ /$uref/ && $iname =~ /$uto/ ) {
            $etmp -= $delmu;
            $jname =~ s/$uref/XX/;
            $iname =~ s/$uto/XX/;
            $nchange ++ ;
         }
      } # end of loop for each pair of tied bases
      # if names match...
      if ( $iname eq $jname ) {
         print LOG "TRUE MATCH: $aname -> $bname with energy change $etmp   nchange=$nchange\n";
         push @tied_states, [ $aname, $bname ];
         push @tied_energies, [ 0.0,   $etmp ];
         $state_adjacent_matrix[$i][$j] = 1; #if states are connected, A_ij = A_ji = 1
         $state_adjacent_matrix[$j][$i] = 1;
         $state_relative_energy[$i][$j] = $etmp; #energy difference at A_ij = Ej-Ei = etmp
         $state_relative_energy[$j][$i] = -$etmp; #energy difference at A_ji = Ei-Ej = -etmp
         if ( $nchange==1 ) { #Note: $nchange is used to see if two states are equivalent (for binding of the other other species)
         ### (i.e. for OF: NoSiWo->NoSbWo->NoSoWo differs by one "equivalent" unit Ni/No, No/Ni from NiSiWo->NiSbWo->NiSoWo)
            push @tied_states_tr, [ $aname, $bname ]; #tied transition state if nchange is 1
         }
      }
   }
}
print LOG "\n";


# From tied states, construct lists with same populations (second version)
%samep_alt = ();
%equiv_alt = ();
@equiv_lists = @{ equiv_list_from_pairs( \@tied_states ) };

# Put the same info into more useful hashes
( $ref_one, $ref_two ) = equiv_hashes_from_list ( \@equiv_lists );
%equiv_alt = %{ $ref_one }; # indicates which key a given state is referenced to
%samep_alt = %{ $ref_two }; # hash giving all states referenced to a key

@samekeys_alt = keys ( %samep_alt );
@dups_alt = (); # list of states which are duplicates of other states - as specified in %samep
print LOG "\nConformationally equivalent states have same populations\n";
foreach $key ( @samekeys_alt ) {
   print LOG "Same pop: $key";
   foreach $x ( @{$samep_alt{$key}} ) {
      push @dups_alt, $x;
      print LOG " and $x";
      $equiv_alt{$x} = $key; # Is this a redundant definition of this hash?
   }
   print LOG "\n";
}
print LOG "DUPLICATES of other states: @dups_alt\n";
print LOG "\n";


@equivkeys_alt = keys(%equiv_alt);
print LOG "These are the equivalents:\n";
foreach $key ( @equivkeys_alt ) {
   print LOG ".. state $key is equivalent (and referenced) to $equiv_alt{$key}\n";
}
print LOG "\n";

if ( $proof==1 ) {
# Now add info on states with fixed relative binding affinity (sugar vs. toxin)
print LOG "\nGenerating tied states lists BASED ON RELATIVE AFFINITIES\n";
for ( $i=0; $i<$nstates; $i++ ) {
   for ( $j=$i+1; $j<$nstates; $j++ ) {
      $iname = $snames[$i]; $aname = $iname;
      $jname = $snames[$j]; $bname = $jname;
      $etmp = 0;
      $nchange = 0; # counter for number of changes to make identical
      foreach $list ( @tied_bases_ne ) {
         $uref = $$list[0]; $uto = $$list[1]; $delmu = $$list[2];
         if ( $iname =~ /$uref/ && $jname =~ /$uto/ ) {
            $etmp += $delmu;
            $iname =~ s/$uref/XX/;
            $jname =~ s/$uto/XX/;
            $nchange ++ ;
         }
         elsif ( $jname =~ /$uref/ && $iname =~ /$uto/ ) {
            $etmp -= $delmu;
            $jname =~ s/$uref/XX/;
            $iname =~ s/$uto/XX/;
            $nchange ++ ;
         }
      } # end of loop for each pair of tied bases
      # goes through remaining connections (i.e. Ni/No)
      foreach $list ( @tied_bases ) {
         $uref = $$list[0]; $uto = $$list[1]; $delmu = $$list[2];
         if ( $iname =~ /$uref/ && $jname =~ /$uto/ ) {
            $etmp += $delmu;
            $iname =~ s/$uref/XX/;
            $jname =~ s/$uto/XX/;
            $nchange ++ ;
         }
         elsif ( $jname =~ /$uref/ && $iname =~ /$uto/ ) {
            $etmp -= $delmu;
            $jname =~ s/$uref/XX/;
            $iname =~ s/$uto/XX/;
            $nchange ++ ;
         }
      }
      #if names match...
      if ( $iname eq $jname ) {
         print LOG "TRUE MATCH: $aname -> $bname with energy change $etmp   nchange=$nchange\n";
         push @tied_states, [ $aname, $bname ];
         push @tied_energies, [ 0.0,   $etmp ];
         $state_adjacent_matrix[$i][$j] = 1; #if states are connected, A_ij = A_ji = 1
         $state_adjacent_matrix[$j][$i] = 1;
         $state_relative_energy[$i][$j] = $etmp; #energy difference at A_ij = Ej-Ei = etmp
         $state_relative_energy[$j][$i] = -$etmp; #energy difference at A_ji = Ei-Ej = -etmp
         # Note: No equivalent transitions generated - only relative affinities
         #if ( $nchange==1 ) {
            #push @tied_states_tr, [ $aname, $bname ];
         #}
      }
   }
}
print LOG "\n";
}
# creates .csv from adjacency matrix and relative energies matrix
matrix_to_csv(\@state_adjacent_matrix, "adjacent_matrix.csv", $nstates, \@snames);
matrix_to_csv(\@state_relative_energy, "energies_matrix.csv", $nstates, \@snames);

# overall initializations (prior to MC loop)
@rates = ();
@edges = (); # a Boolean variable for visualizing/accessing non-zero values of rate matrix
%ebars = (); # transition state energies (above max of pairs) hash by state-pair name
@diag = (); # Diagonal elements of rate matrix - minus the sum of each row
@matrix = (); # matrix direclty used to solve steady state
@s_edges = (); # list of edges which actually generate sugar/substrate flow to inside
               # to be populated by function edge_checker_in
@w_edges = (); # list of edges which actually generate toxin/W flow to inside
               # to be populated by function edge_checker_tox
@n_edges = (); # list of edges which lead to ion flow
               # to be populated by function edge_checker_ion
@alt_states = (); # states in the projected space of conformationally unique states
%alt_indices = (); # hash to indices of alt_states
@alt_rates = (); # rates in the projected space - won't satisfy detailed balance
@alt_matrix = (); # matrix to be solved in the projected space
@slowpairs = (); # list of slow transitions - e.g., unbinding to inside from outward-facing
#$first_early = 1;  # $first_late = 1; # flags for changing beta values

# Construct list of alternative (conformationally unique) states
print LOG "\nAlternative states (conformationally unique)\n";
$ialt = 0;
for ( $i=0; $i<$nstates; $i++ ) {
   $istate = $states[$i][0];
   unless ( grep { $istate eq $_ } @equivkeys_alt ) {
      $alt_states[$ialt] = $istate;
      $alt_indices{$istate} = $ialt;
      print LOG "Alt state $alt_indices{$istate} = $alt_states[$ialt]\n";
      $ialt ++;
   }
}
$n_alt = @alt_states;
print LOG "\n";

# initialize barrier energies
initialize_barriers(); # defines hash of barrier heights, ebars
@barkeys_unordered = keys %ebars; #note that is is unordered and different for each runtime
@barkeys = sort @barkeys_unordered; #sorts barkeys so it is the same order for each run! (otherwise trial move picks different barriers)
# correct barrier energies based on tied states
print LOG "\n";
foreach $tlist ( @tied_states_tr ) { # now all are two element arrays
   $aname = $$tlist[0]; $bname = $$tlist[1];
   print LOG "TIED PAIR for TRANSITION: $aname  $bname\n";
}


### Further intializations and prints
# print all state pairs
print LOG "\n\nNames of state pairs ...\n";
foreach $pair ( @barkeys ) {
  print LOG "State pair = $pair .... ebar = $ebars{$pair}\n";
}


my @tmp_transition_state_list = ();
my @transition_state_list = ();
my %hash_equiv_transns = ();
my $equiv_tansns_name = "";

# find equivalent transitions
print LOG "\nFinding equivalent transitions\n";
@equiv_transns = ();
$etcount = 0; #tracks number of equivalent transitions

for ( $i=0; $i<@barkeys; $i++ ) {
  $apair = $barkeys[$i]; #pick a barrier (i.e. transition state)
  $apair_copy = $apair;
  @apair_split = split  /-|_/, $apair; #converts string into list of substrings
  for ($k=0; $k<$n_units; $k++) { #go through each base unit to find base transition
    if ($apair_split[$k] ne $apair_split[$k+$n_units+1] ){ #compare base units of each states. "+1" term skips over 'AND'
      @apair_trans = ("$apair_split[$k]","$apair_split[$k+$n_units+1]"); #save transition base units for comparision later "key transition"
      $apair_split[$k] = "XX"; #replace transition with XXs (so we can check if equal with second transition state)
      $apair_split[$k+$n_units+1] = "XX";
      $apair_copy =~ s/$apair_split[$k]/XX/;
      $apair_copy =~ s/$apair_split[$k+$n_units+1]/XX/;
    }
  }

  for ( $j=$i+1; $j<@barkeys; $j++ ) {
     $bpair = $barkeys[$j]; #pick next barrier
     @bpair_split = split  /-|_/, $bpair;
     $bpair_copy = $bpair;
     $both_trans = "$apair to $bpair";
     $equal_base_count = 0; #tracks the number of base units that are equal/equiv

     if ( $apair ne $bpair ) {#don't compare the same transitions
       #if second pair has the same base transition
       if ( $bpair =~ m/$apair_trans[0]/ && $bpair =~ m/$apair_trans[1]/){
            for ($k=0; $k<$n_units; $k++) { #go through each base unit to find base transition
              if ($bpair_split[$k] ne $bpair_split[$k+$n_units+1] ){ #compare base units of each states. "+1" term skips over 'AND'
                #@bpair_trans = ("$bpair_split[$k]","$bpair_split[$k+$n_units+1]"); #save transition base units for comparision later "key transition"
                $bpair_split[$k] = "XX"; #replace transition with XXs (so we can check if equal with second transition state)
                $bpair_split[$k+$n_units+1] = "XX";
                $bpair_copy =~ s/$bpair_split[$k]/XX/;
                $bpair_copy =~ s/$bpair_split[$k+$n_units+1]/XX/;
              }
            }
            #check for a transition with Sb = Wb state (i.e. OF-No-Sb-Wo to OF-Nb-Sb-Wo = OF-No-So-Wb to OF-Nb-So-Wb)
            if ($Sb_Wb_tied == 2 || $Sb_Wb_tied == 3 ){
                foreach $tlist (@Sb_Wb_tied_list){
                  if ( ( (grep /$$tlist[0]/, $apair) && (grep /$$tlist[1]/, $bpair) ) || ( (grep /$$tlist[1]/, $apair) && (grep /$$tlist[0]/, $bpair) ) ){
                    $equal_base_count = 2; #s and w terms are equiv.
                  }
                }
            }
            #check remaining bases
            for ($m=0; $m<$n_units; $m++){
               if ($apair_split[$m] eq $bpair_split[$m] ){ #check for equal bases
                   $equal_base_count++;
                } else { #check for equivalent bases
                       for ($n=0; $n<@tied_bases; $n++) {
                            if ( (grep /$apair_split[$m]/, @{$tied_bases[$n]}) && (grep /$bpair_split[$m]/, @{$tied_bases[$n]}) ){
                                $equal_base_count++;
                            }
                       }
               } # end of else { #check for equivalent bases
           }
      } else { #transitions do not have same "key transition"
          if ($Sb_Wb_tied == 1 || $Sb_Wb_tied == 3 ){ #check for "proof-reading equivalent" (i.e. So->Sb = Wo->Wb)
            foreach $tlist (@tied_for_bind){
              $aname = $$tlist[0]; $bname = $$tlist[1]; $cname = $$tlist[2]; $dname = $$tlist[3];
              if ( $apair =~ m/$aname/ && $apair =~ m/$bname/  && $bpair =~ m/$cname/ && $bpair =~ m/$dname/ ) {
                $equal_base_count = 2;
              }
              elsif ($apair =~ m/$cname/ && $apair =~ m/$dname/  && $bpair =~ m/$aname/ && $bpair =~ m/$bname/ ){
                $equal_base_count = 2;
              }
            }
            for ($m=0; $m<$n_units-2; $m++){ #check remaining bases (not S and W)
              if ($apair_split[$m] eq $bpair_split[$m] ){ #check for equal bases
              $equal_base_count++;
            } else { #check for equivalent bases (not S and W)
                  for ($n=0; $n<@tied_bases-2; $n++) {
                       if ( (grep /$apair_split[$m]/, @{$tied_bases[$n]}) && (grep /$bpair_split[$m]/, @{$tied_bases[$n]}) ){
                           $equal_base_count++;
                       }
                  }
                } # end of else { #check for equivalent bases
            }
          }
    }
  } # end of if ( $apair ne $bpair )

  if ( $equal_base_count eq $n_units) { #each base unit must match
    $etcount ++ ;
    print LOG ".. Equivalent transition $etcount: $both_trans\n";
    push @equiv_transns, [ $apair, $bpair ];
    push @tmp_transition_state_list, $apair;
    push @tmp_transition_state_list, $bpair;
    $equiv_tansns_name = "$apair $bpair";
    $hash_equiv_transns{"$equiv_tansns_name"} = "1";
    }
  } # end of j loop
} # end of i loop


my %tmp_hash_of_transition_states = map { $_, 1 } @tmp_transition_state_list;
@transition_state_list = keys %tmp_hash_of_transition_states;

$n_transition_states = @transition_state_list;

my @transition_adjacent_matrix = ();
push @transition_adjacent_matrix, [(0)x$n_transition_states] for (1..$n_transition_states);

my @transition_energy_matrix = ();
push @transition_energy_matrix, [(0)x$n_transition_states] for (1..$n_transition_states);

for ( $i=0; $i<@transition_state_list; $i++ ) {
    for ($j=$i+1; $j<@transition_state_list; $j++){
        #check if both transition states are in dictionary
        $transition_energy_matrix[$i][$j] = $ebars{$transition_state_list[$j]}-$ebars{$transition_state_list[$i]};
        $transition_energy_matrix[$j][$i] = $ebars{$transition_state_list[$i]}-$ebars{$transition_state_list[$j]};
        $key1 = "$transition_state_list[$i] $transition_state_list[$j]";
        $key2 = "$transition_state_list[$j] $transition_state_list[$i]";
        if ( (exists($hash_equiv_transns{$key1})) or (exists($hash_equiv_transns{$key2})) ) {
            $transition_adjacent_matrix[$i][$j] = 1;
            $transition_adjacent_matrix[$j][$i] = 1;
        }
    }
}
matrix_to_csv(\@transition_adjacent_matrix, "transition_state_adjacent_matrix.csv", $n_transition_states, \@transition_state_list);
matrix_to_csv(\@transition_energy_matrix, "transition_state_energy_matrix.csv", $n_transition_states, \@transition_state_list);


# Information for maintaining equivalent barrier heights for equivalent transitions
# Makes lists of equivalent barriers (transitions)
@equiv_lists_tr = @{ equiv_list_from_pairs( \@equiv_transns ) };


print LOG "\nLists of equivalent transitions\n";
foreach $list ( @equiv_lists_tr ) {
  print LOG "Equiv list: @{$list}\n";
}

# uses python script to generate (from graph) connected states/energies and initialize MC model
python_networkx();
my ($connected_states, $connected_transitions) = import_from_python();
print LOG "connected states\n".Dumper($connected_states);
print LOG "connected transitions\n".Dumper($connected_transitions);

print LOG "intializing model...\n";
initial_model($connected_states, $connected_transitions);
if ($proof==1){
  @reference_states = set_reference_state($connected_states,"OF-No-So-Wo"); #pick a top level reference state (alt state) or chooses randomly. Returns group of connected states to ref.
} else {
  @reference_states = set_reference_state($connected_states,"OF-No-So");
}

#print DEBUG "reference_states\n".Dumper(@reference_states);
# Put the same info into more useful hashes
( $ref_one, $ref_two ) = equiv_hashes_from_list ( \@equiv_lists_tr );
%equiv_tr = %{ $ref_one }; # indicates which key a given transn is referenced to
%same_bar = %{ $ref_two }; # hash giving all states referenced to a key

@samekeys_tr = keys ( %same_bar );
@dups_tr = (); # list of all transitions equivalent to some other

foreach $key ( @samekeys_tr ) {
  foreach $x ( @{$same_bar{$key}} ) {
     push @dups_tr, $x;
  }
}
print LOG "DUPLICATES of other transitions: @dups_tr\n";
print LOG "\n";


# display non-zero edges matrix
print LOG "\nNon-zero edges matrix:\n";
for ( $i=0; $i<@states; $i++ ) {
  print LOG "i=$i   $states[$i][0]     ";
  for ( $j=0; $j<@states; $j++ ) {
     print LOG "$edges[$i][$j]  ";
  }
  print LOG "\n";
}

# show edges leading to transport
print LOG "\nThese edges lead to the transport process encoded in goals array:\n";
foreach $sedge ( @s_edges ) {
  print LOG "... from state $$sedge[0] to $$sedge[1]\n";
}
print LOG "\n";

# show edges leading to toxin transport
if ( $proof==1 ) {
  print LOG "\nThese edges lead to the transport process encoded in not_goals array:\n";
  foreach $wedge ( @w_edges ) {
     print LOG "... from state $$wedge[0] to $$wedge[1]\n";
  }
  print LOG "\n";
}

  #$barrier_max = 80.0;
  ### beta parameter configuration
  $b_step_low = $temp_scale * 125;  # high T
  $b_step_high = $temp_scale * 1450;  # low T
  $b_step_inc = $temp_scale * 100;  # dec T
  $b_step_dec = $temp_scale * 325;  # inc T
  $beta_step_1 = $b_step_low;
  $beta_step_2 = $b_step_low + $b_step_inc;
  $beta_step_3 = $b_step_low + $b_step_inc + $b_step_high;
  $beta_step_4 = $b_step_low + $b_step_inc + $b_step_high + $b_step_dec;
  $beta_increment = ($b_max/$b_min) ** (1/($b_step_inc));  # how much to increase beta
  $beta_decrement = ($b_max/$b_min) ** (1/($b_step_dec));  # how much to increase beta
  print LOG "b step low: $b_step_low b step high: $b_step_high  b step inc:$b_step_inc  b step dec:$b_step_dec \n";
  print LOG "bmax: $b_max  bmin: $b_min \n";
  print LOG "increment (*) beta by: $beta_increment\n";
  print LOG "decrement (*) beta by: $beta_decrement\n";

  print BETA "n, emc, beta, delta e, phase, status, ratio, exp(-beta*delta e)\n";
  my $phase = "initial";

  open(my $fh_d, ">", "matrix_and_soln.dat") or die "Error! Cannot open file";

################################################################
for ( $n=0; $n<=$nsteps; $n++ ) { # MONTE CARLO LOOP
################################################################
    if ( $n%$dprint==0 ) {
      $duration = time() - $start_time;
      warn "M.C. n = $n. Duration (s) = $duration\n ";
    }

  #print $fh_d "test $n\n";
  print MCFILE "\nMonte Carlo loop: n = $n\n\n";
  print LOG "\nMonte Carlo loop: n = $n\n\n";
  #print DEBUG "\n\nMonte Carlo loop: n = $n\n\n";

  #to compare energies before/after
  $old_connected_states = dclone $connected_states;
  $old_connected_transitions = dclone $connected_transitions;


  ## Trial move
  if ( $n>0 ) {

     # choose random state or transition-state energy to perturb
     if ( rand() < 0.5 ) { # trial move is perturbation to state energy
        $state_move = 1;  # 1 for changing state, 0 for changing barrier
        $state_ok = 0; # flag for whether chosen state is in fixed list and should be excluded
        while ( $state_ok==0 ) {
           $nrand = floor(rand()*$nstates); # random element of states array
           #print MCFILE "nstates = $nstates   nrand = $nrand\n";
           $tmpstate = $states[$nrand][0];
           if ( (grep { $tmpstate eq $_ } @reference_states) ){#debugging
           }
           if ( (grep { $tmpstate eq $_ } keys %fixed_states) ){#debugging
           }
           unless ( (grep { $tmpstate eq $_ } keys %fixed_states)  || ((grep { $tmpstate eq $_ } @reference_states))  ) { $state_ok = 1; }
           #print MCFILE "MC: chosen state $tmpstate    state_ok = $state_ok\n";
        }
        $delta_e = 2.0*$demax*( rand() - 0.5 ); # amount by which energy of state to be perturbed
        $old_energy = $energies{$tmpstate}; # keep track of perturbed state's energy
        $new_energy = $old_energy + $delta_e; # perturb energy
        $energies{$tmpstate} = $new_energy; # set state's energy to new energy
        print MCFILE "Perturb state $tmpstate by delta_e=$delta_e from $old_energy to $new_energy\n";
        adjust_tied_energies2( $tmpstate, $connected_states, $delta_e); #use delta_e because some states in equivalent group have different energies, can't set them all to new energy
        unit_test_tied_energy_difference($old_connected_states, $connected_states, "states" );
     }
     else { # trial move is perturbation to transition-state (energy barrier) energy
        $state_move = 0;
        $nbars = keys %ebars;
        $nrand = floor(rand()*$nbars); # random element of transition states array
        $bartmp = $barkeys[$nrand]; # name of transition state to be perturbed
        print MCFILE "Perturb transition state $nrand = $bartmp  with  ebar = $ebars{$bartmp}\n";
        $delta_e = 2.0*$demax*( rand() - 0.5 ); # amount by which energy of state to be perturbed
        $old_energy = $ebars{$bartmp};
        $new_energy = $old_energy + $delta_e;
        if ( grep { $bartmp eq $_ } @slowpairs ) {
           print MCFILE "... CHANGING A SLOW TRANSN STATE\n";
           if ( $new_energy < $ebarslow ) {  # slow transition -> make large barrier
             $new_energy = $ebarslow;
             $delta_e = $ebarslow-$old_energy;   #change delta e such that old energy + delta = ebar slow
            } # elsif ($new_energy >  $ebarslow + $barrier_max){
         #      print "$n barrier energy $bartmp set too high: $new_energy. Setting to max: $ebarslow + $barrier_max.\n";
         #      warn "$n barrier energy $bartmp set too high: $new_energy. Setting to max: $ebarslow + $barrier_max.\n";
         #      $new_energy = $ebarslow + $barrier_max;
         #      $delta_e = ($ebarslow + $barrier_max)-$old_energy;
         #      print "bartmp = $bartmp, old energy = $old_energy, delta_e = $delta_e, new_energy = $new_energy, bar_max = $barrier_max \n";
         #   }
         } elsif ( $new_energy < 0.0 ) { #fix this?
              $new_energy = 0.0; # equivalent to setting minimum rate to be kzero
              $delta_e = 0.0;  #change delta e such that old energy + delta = 0
         } # elsif ( $new_energy > $barrier_max ) {
      #          print "$n barrier energy $bartmp set too high: $new_energy. Setting to max: $barrier_max.\n";
      #          warn "$n barrier energy $bartmp set too high: $new_energy. Setting to max: $barrier_max.\n";
      #          $new_energy = $barrier_max; # barrier is capped to maximum
      #          $delta_e = $barrier_max - $old_energy;
      #          print "bartmp = $bartmp, old energy = $old_energy, delta_e = $delta_e, new_energy = $new_energy, bar_max = $barrier_max \n";
      #        }
        $ebars{$bartmp} = $old_energy + $delta_e;
        print MCFILE "Perturb transition state $bartmp by delta_e=$delta_e from $old_energy to (non-negative) $new_energy\n";
        adjust_tied_barriers2( $bartmp, $connected_transitions, $delta_e);
        unit_test_tied_energy_difference($old_connected_transitions,$connected_transitions, "transitions");
     }
  }


  # Create/re-generate rates and matrix to evaluate initial state or trial move
  # array of state pairs
  # create/update transition matrix of rates, matrix to solve, and hash of transn-state energies
  %ebar_hash = (); #testing
  $i=0;
  foreach $sa (@states) {
     $j=0;
     $diag[$i] = 0;
     foreach $sb (@states) {
        $a_name = $$sa[0];
        $b_name = $$sb[0];
        if ( $i<$j ) {
            $pairname = $a_name."_AND_".$b_name;
        }
        else         { # pairname INDEPENDENT of order
            $pairname = $b_name."_AND_".$a_name;
        }
        $d = distance( \@$sa, \@$sb, \@unit_lengths ); # passing references

        if ( $d==1 ) { # transitions only allowed between 'nearest-neighbor' states
           $energy_a = $energies{$a_name};
           $energy_b = $energies{$b_name};
           $ddmu = 0.0;
           if ( is_binding( $a_name, $b_name ) ) { # rate adjustments based on ligand concentration - binding only
              $dmu_a = $energies_noneq{$a_name}; # log of concentration diff of a vs. equil
              $dmu_b = $energies_noneq{$b_name}; # log of concentration diff of a vs. equil
              $ddmu = $dmu_a - $dmu_b;
              #print LOG "New rate: ddmu = $ddmu    $a_name  =>  dmu_a = $dmu_a  ...  $b_name => dmu_b = $dmu_b\n";
           }
           $emax = 0.5*(  $energy_a + $energy_b + abs( $energy_a - $energy_b ));
           $ebar = $emax + $ebars{$pairname}; # transition state energy
           $ebar_hash{$pairname} = $ebar; #TESTING
           $rateij = exp( $ddmu ) * $kzero * exp( -( $ebar - $energy_a ) ); # simple Arrhenius rate * ligand conc
           if ($rateij > 1e20){  # check for very large rates...
              print "$n WARNING! Rate is very large: $rateij";
              print LOG "$n WARNING! Rate is very large: $rateij";
              warn "$n WARNING! Rate is very large: $rateij";
           } 
           if ($rateij >  exp( $ddmu ) * $kzero){
               print "$n WARNING! Rate $rateij is above exp( $ddmu ) * $kzero";
               print LOG "$n WARNING! Rate $rateij is above exp( $ddmu ) * $kzero";
               warn "$n WARNING! Rate $rateij is above exp( $ddmu ) * $kzero";
            }


        }
        else { # distance not 1, so rate is zero
           $rateij = 0.0;
           $edges[$i][$j] = 0;
        }
        $rates[$i][$j] = $rateij;
        $matrix[$i][$j] = $rates[$i][$j]; # what will actually be used to solve
        $diag[$i] -= $rateij;
        $j++;
     }
     $matrix[$i][$i] = $diag[$i];
     $rates[$i][$i] = $diag[$i];
     $matrix[$i][@states-1] = 1; # for probability constraint
     $i++;
  }

  ### Make alternative rate matrix needed to find populations
  #print LOG "\nConstructing alt_rates matrix\n";
  for ( $i=0; $i<$n_alt; $i++ ) { # zero out rates because they're re-summed each MC step
     for ( $j=0; $j<$n_alt; $j++ ) {
        $alt_rates[$i][$j] = 0.0;
     }
  }
  # sum over all rates from equivalent states
  for ( $i=0; $i<$nstates; $i++ ) { # run through original indices
     $ialt = equiv_state($i);
     for ( $j=0; $j<$nstates; $j++ ) {
        $jalt = equiv_state($j);
        #print LOG "Making new matrix states $i = $istate and $j = $jstate\n";
        unless ( $i==$j) { $alt_rates[$ialt][$jalt] += $rates[$i][$j]; }
     }
  }
  # add diagonal elements
  for ( $i=0; $i<$n_alt; $i++ ) { # zero out rates because they're re-summed each MC step
     $sum = 0.0;
     for ( $j=0; $j<$n_alt; $j++ ) {
        unless ( $i==$j) { $sum -= $alt_rates[$i][$j]; }
     }
     $alt_rates[$i][$i] = $sum;
  }
  # print the alt rates matrix and define the matrix for solution
  #print LOG "\n\nPresenting the alternate rate matrix ....\n";
  for ( $i=0; $i<$n_alt; $i++ ) { # zero out rates because they're re-summed each MC step
     for ( $j=0; $j<$n_alt; $j++ ) {
        #printf("%5.2e  ", $alt_rates[$i][$j]);
        if ( $j < $n_alt-1 ) {
           $alt_matrix[$i][$j] = $alt_rates[$i][$j];
        }
     }
     $alt_matrix[$i][$n_alt-1] = 1; # for probability constraint
     #print LOG "\n";
  }
  #print LOG "\n\n";


  # write rates file for inspection
  open(KFILE, "> $kfile") or die "Error! Cannot open $kfile" ;
  for ( $i=0; $i<@states; $i++ ) {
     for ( $j=0; $j<@states; $j++ ) {
        printf KFILE "%8.4e  ", $rates[$i][$j];
     }
     print KFILE "\n\n";
  }
  close(KFILE) or die "Error! Cannot close";

  #print $fh_d "$n ";
  # if ($n%$dprint==0 ){
  #   print $fh_d "$n, " x scalar @alt_matrix;
  #   print $fh_d "\n";
  #   foreach my $row (@alt_matrix) {
  #     foreach my $element (@$row) {
  #       print $fh_d "$element, " ;
  #     }
  #     print $fh_d "\n";
  #   }
  # }


call_pdl( \@alt_matrix, $tmpfile);


  # retrieve steady-state probabilities for alt states
  @alt_pss = ();

  $pss_zero_count = 0;
  $pss_error_flag = 0;
  $pss_sum = 0;
  open(TMP, "$tmpfile") or die "Error! Cannot open $tmpfile";
  while (<TMP>) {
     $_ =~ s/\[/ /;
     $_ =~ s/\]/ /;
     @vals = split ' ', $_;
   #   if (scalar @vals == 0){
   #       $pss_error_flag = 1;
   #       print LOG "WARNING! No SS probabilites in file... Likely due to singular matrix error. Error flag is set and move will be rejected.\n";
   #       print "WARNING! No SS probabilites in file... Likely due to singular matrix error. Error flag is set and move will be rejected.\n";
   #       warn  "WARNING! No SS probabilites in file... Likely due to singular matrix error. Error flag is set and move will be rejected.\n";
   #   }
     #print LOG "reading line in tmpfile: @vals\n";
     foreach $val ( @vals ) {
        $x = 1.0*$val;
        $pss_sum = $pss_sum + $x;
        # if ($n%$dprint==0 ){
        #   print $fh_d "$x, ";
        # }
        if ($x==0){
           $pss_zero_count += 1;
        }
        push @alt_pss, $x;
     }
  }
  # if ($n%$dprint==0 ){
  #     print $fh_d "\n\n";
  # }
  
  print LOG "steady state values: @alt_pss\n\n";
  close(TMP) or die "Error! Cannot close";
  if ($pss_zero_count == scalar @alt_pss){
     $pss_error_flag = 1;
     print LOG "$n WARNING! All SS probabilities = 0. Likely due to singular matrix error. Error flag is set and move will be rejected.\n";
     print "$n WARNING! All SS probabilities = 0. Likely due to singular matrix error. Error flag is set and move will be rejected.\n";
     warn "$n WARNING! All SS probabilities = 0. Likely due to singular matrix error. Error flag is set and move will be rejected.\n";
  }
  if (abs(1-$pss_sum) >= 0.01 ){
     $pss_error_flag = 1;
     print LOG "$n WARNING! Sum of SS probabilities != 1. Likely due to singular matrix error. Error flag is set and move will be rejected.\n";
     print "$n WARNING! Sum of SS probabilities != 1. Likely due to singular matrix error. Error flag is set and move will be rejected.\n";
     warn "$n WARNING! Sum of SS probabilities != 1. Likely due to singular matrix error. Error flag is set and move will be rejected.\n";
  }

  # assign steady-state probabilities to all states
  @pss = ();
  for ( $i=0; $i<$nstates; $i++ ) { # run through original indices
     $ialt = equiv_state($i); # index of reference state with same prob
     $pss[$i] = $alt_pss[$ialt];
     #print LOG "State $i inherits prob $alt_pss[$ialt] from state $ialt\n";
  }

  # Calculate MC energy score for trial perturbation check accept/reject
  if ( $n>0 ) { # record old values
     $emc_old = $emc;
  }
  @energy_info = mc_energy ();
  $emc =  $energy_info[0];
  ( $sflow, $wflow, $nflow ) = ( $energy_info[1], $energy_info[2], $energy_info[3] );

  # if ($proof == 1){
    #$emc = avg_emc();  # testing averaging out emc for different dmu
  #}

  if ( $n==0 ) {
     $emc_old = $emc; $n_accept = 0;
     # Output data for analysis
     print DATA "# n_mc   mc_energy   ";
     print FLOWS "# n_mc   ";
     for ( $i=0; $i<@states; $i++ ) {
        for ( $j=0; $j<@states; $j++ ) {
           if ( $edges[$i][$j] == 1 ) {
              print DATA "$states[$i][0]_TO_$states[$j][0]   ";
              print FLOWS "$states[$i][0]_TO_$states[$j][0]   ";
           }
        }
     }
     print DATA "\n";
     print FLOWS "\n";

  }


  if ( $n>0 ) { # check if move accepted

     if ( $n%$n_beta==0 ) {  # routine to adjust beta values
        if ( $n==1 ) {  # initialize
           #$ebeta_old = $emc; # ebeta_old is emc at prior beta check point
           #$beta = $beta_init;
           $beta = $b_min;
           $tempering_count = 0;
           $phase = "max temp";
        }
        else { #  either increase beta or reset beta to intitial value
          #print BETA "n: $n Emc: $emc old beta: $beta tempering count: $tempering_count\n";
          if ($tempering_count < $beta_step_1){  # stay at low value
            #print BETA "staying at low beta value\n";
            $tempering_count += 1;
            $beta = $b_min;  # probably unecessary
            $phase = "max temp";
            #print BETA "beta stayed at min: $beta\n";
          } elsif ($tempering_count < ($beta_step_2)) {  # increase beta
            $tempering_count += 1;
            $beta *= $beta_increment;
            $phase = "cooling";
            #print BETA "beta is increased to: $beta\n";
          } elsif ($tempering_count < ($beta_step_3)) {  # at max beta
            $tempering_count += 1;
            $beta = $b_max;
            $phase = "min temp";
            #print BETA "beta stayed at max: $beta\n";
          } elsif ($tempering_count < ($beta_step_4)) {  # decrease beta
            $tempering_count += 1;
            $beta /= $beta_decrement;
            $phase = "heating";
            #print BETA "beta is decreased to: $beta\n";
          } else {  # reset beta
            $tempering_count = 0;
            $phase = "reset";
            #print BETA "reseting beta to min: $b_min\n";
          }
        }

     #       $beta_old = $beta;
     #       print BETAG "";
     #       print LOG "Beta: emc = $emc    ebeta_old = $ebeta_old      beta_old = $beta_old\n";
     #       print  "n = $n Beta: emc = $emc    ebeta_old = $ebeta_old      beta_old = $beta_old \n";
     #       $frac_diff = 2.0*( $emc - $ebeta_old ) / ( abs($emc) + abs($ebeta_old) );
     #       #$frac_diff = $emc - $ebeta_old;  # testing
     #       $ebeta_old = $emc; # ebeta_old is emc at prior beta check point
     #       $scale_fac = rand()*$fbeta;
     #       $de = $emc - $emc_old;  # for debugging
     #       print "frac diff = $frac_diff  scale_fac = $scale_fac tol = $tol \n";
     #       print BETAG "$n   $beta   ";
     #       print BETA "n, emc, beta, delta emc, beta frac diff, tol \n";  # testing
     #       print BETA "$n, $emc, $beta, $de, $frac_diff, $tol\n";  #testing
     #       print BETA "if abs($frac_diff) < $tol, decrease. else if $frac_diff < $tol, possibly increase\n";
     #       #print BETA "n = $n b1 = $beta_old e2 = $emc e1 = $ebeta_old de = $de frac diff = $frac_diff scale fac = $scale_fac tol=$tol\n";
     #       if ( abs($frac_diff) < $tol ) { # energy change approximately constant - decrease beta
     #          print "energy change approximately constant - decrease beta\n";
     #          print BETA "energy change approximately constant - decrease beta\n";
     #          #print BETA "energy change approximately constant - decrease beta\n";
     #          $beta /= $scale_fac;
     #       }
     #       elsif ( $frac_diff <= $tol ) { # energy has decreased - possibly increase beta
     #          print "energy has decreased\n";
     #          print BETA "energy has decreased\n";
     #          if ( rand() > $pbeta_stay ) {
     #            print "energy has decreased - possibly increase beta\n";
     #            print BETA "energy has decreased - and will now increase beta\n";
     #            #print BETA "energy has decreased - possibly increase beta\n";
     #            $beta *= $scale_fac;
     #          }
     #       }
     #
     #
     #       print BETA "n:$n reset beta every: $n_beta_reset\n";
     #       if ($n%$n_beta_reset == 1){ # testing. reset beta periodically
     #         $beta = $beta_init;
     #         print BETA "beta is reset to initial value = $beta_init\n";
     #       }
     #
     #
     #       print BETA "$n, $emc, $beta, $de, $frac_diff\n";  #testing
     #       #elsif ( $frac_diff >= $tol ) { # energy has increased - possibly decrease beta
     #          #if ( rand() > $pbeta_stay ) { $beta /= $scale_fac; }
     #       #}
     #       #printf BETA "MC: Based on frac_diff = %6.3e,  beta is now %6.3e\n", $frac_diff, $beta;
     #       printf "\nMC: Based on frac_diff = %6.3e,  beta is now %6.3e\n\n", $frac_diff, $beta;
     #       printf LOG "\nMC: Based on frac_diff = %6.3e,  beta is now %6.3e\n\n", $frac_diff, $beta;
     #       printf MCFILE "\nMC: Based on frac_diff = %6.3e,  beta is now %6.3e\n\n", $frac_diff, $beta;
     #    }
     #    print BETA "\n";
     }
     #warn "tempering count = $tempering_count\n";
     $ediff = $emc - $emc_old;
     $b_factor = exp(-$beta*$ediff);
     print MCFILE "$n MC energies: emc=$emc   emc_old=$emc_old   ediff = $ediff\n";
     print "$n MC energies: emc=$emc   emc_old=$emc_old   ediff = $ediff\n";

     if ( ($ediff < 0 || rand() < $b_factor ) && $pss_error_flag != 1) { # Accept - keep things as they are
        $mc_change = 1;
        $n_accept ++; $accept_ratio = $n_accept/$n;
        print MCFILE "$n Move accepted!   Acceptance ratio = $accept_ratio\n";
        print "$n Move accepted!   Acceptance ratio = $accept_ratio\n";
        #print BETA "Move accepted!   Acceptance ratio = $accept_ratio\n";
        print BETA "$n, $emc, $beta, $ediff, $phase, accepted, $accept_ratio, $b_factor\n";
     }
     else { # Rejection
        $mc_change = 0;
        $accept_ratio = $n_accept/$n;
        print MCFILE "$n Move rejected!!!    Acceptance ratio = $accept_ratio\n";
        print "$n Move rejected!!!    Acceptance ratio = $accept_ratio\n";
        print BETA "$n, $emc, $beta, $ediff, $phase, rejected, $accept_ratio, $b_factor\n";
        #print BETA "Move rejected!!!    Acceptance ratio = $accept_ratio\n";
        if ( $state_move == 1 ) { # state energy was changed - change back
           $energies{$tmpstate} = $old_energy;
           print MCFILE "$n State rejection: Change back state $tmpstate to $energies{$tmpstate}\n";
           adjust_tied_energies2( $tmpstate, $connected_states, -1*$delta_e);#note: negative change in energy used to reset
           unit_test_check_restored_energies($old_connected_states, $connected_states, "states");
        }
        else { # transition state energy was changed - change back
           $ebars{$bartmp} = $old_energy;
           print MCFILE "$n Barrier rejection: Change back transition state $bartmp to  $ebars{$bartmp}\n";
           adjust_tied_barriers2( $bartmp, $connected_transitions, -1*$delta_e); #note: negative change in energy used to reset
           unit_test_check_restored_energies($old_connected_transitions, $connected_transitions, "transitions");
        }
        $emc = $emc_old;
     }
     #print BETA "\n";
  }

  # print rates etc to file for plotting/analysis
  $omit_this = 1;
  %branches = ();
  @netflow = ();
  if ( $n%$dprint==0 ) {
     print DATA "$n   $emc   ";
     #print BETA "$n   $beta  \n"; # testing
     unless ( $omit_this==1 ) {
     #print LOG "\nn = $n (Monte Carlo step number)      emc = $emc\n";
     print FLOWS "$n   ";
     for ( $i=0; $i<@states; $i++ ) {
        $a_name = $states[$i][0];
        #testing
        #print LOG "\nBRANCHING FRACTIONS FROM STATE $a_name ...\n";
        $branch_sum = 1e-99;
        for ( $j=0; $j<@states; $j++ ) {
           if ( $edges[$i][$j] == 1 ) {
              $b_name = $states[$j][0];
              $transn = $a_name . "_TO_" . $b_name;
              print DATA "$rates[$i][$j]   ";
              $flowtmp = flow( $a_name, $b_name );
              $rflowtmp = flow( $b_name, $a_name );
              $netflow[$i][$j] = $flowtmp - $rflowtmp;
              $branches{$transn} = $flowtmp;
              $branch_sum += $flowtmp;
              printf FLOWS "%6.3e  ", $flowtmp;
              if ( $rates[$i][$j]>$kzero*1e-3 ) { # print rates which are significant
                 print MCFILE "TRANSN ON: $a_name to $b_name with k = $rates[$i][$j]\n";
              }
              else { print MCFILE "TRANSN OFF: $a_name to $b_name ...... with k = $rates[$i][$j]\n";}
           } # end of if edges loop
        } # end of first j loop
        # second j loop to get branching ratios
        for ( $j=0; $j<@states; $j++ ) {
           if ( $edges[$i][$j] == 1 ) {
              $b_name = $states[$j][0];
              $transn = $a_name . "_TO_" . $b_name;
              $branches{$transn} /= $branch_sum;
              #testing
              #printf LOG "   %s  %5.3f <= %6.2e  Net flow = %6.2e\n",  $transn, $branches{$transn}, $branches{$transn}, $netflow[$i][$j];
           } # end of if edges loop
        } # end of second j loop
        #print LOG "\n"; # testing
     }
     print FLOWS "\n";
     } # end of omit_this
     print DATA "\n";
  }

  if ( $n==0 || $mc_change==1 ) { # save flows for accepted moves
     @netflow_save = ();
     $sflow_save = $sflow;
     $wflow_save = $wflow;
     $nflow_save = $nflow;
     for ( $i=0; $i<@alt_states; $i++ ) {
        $a_name = $alt_states[$i];
        for ( $j=0; $j<@alt_states; $j++ ) {
           if ( $alt_rates[$i][$j] > 0 ) {
              $b_name = $alt_states[$j];
              $transn = $a_name . "_TO_" . $b_name;
              $flowtmp = flow_alt( $a_name, $b_name );
              $rflowtmp = flow_alt( $b_name, $a_name );
              $netflow_save[$i][$j] = $flowtmp - $rflowtmp;
           } # end of if edges loop
        } # end of first j loop
        print LOG "\n";
     }
  }
  # print flows among physical ('alt') states (based on last accepted move)
  if ( $n%$dprint==0 ) {

     print LOG "\nn = $n (Monte Carlo step number)      emc = $emc\n";
     print CLUSTER "$n, $emc";
     print LOG "S flow = $sflow_save    W flow = $wflow_save    N flow = $nflow_save\n";
     for ( $i=0; $i<@alt_states; $i++ ) {
        $a_name = $alt_states[$i];
        print LOG "\nOVERALL PHYSICAL FLOWS FROM STATE $a_name ...\n";
        for ( $j=0; $j<@alt_states; $j++ ) {
           if ( $alt_rates[$i][$j] > 0 ) {
              $b_name = $alt_states[$j];
              $transn = $a_name . "_TO_" . $b_name;
              printf LOG " %s    Net flow = %6.2e\n",  $transn, $netflow_save[$i][$j];
              printf CLUSTER ",$netflow_save[$i][$j]";
           } # end of if edges loop
        } # end of first j loop
        print LOG "\n";
     }
     print CLUSTER ", $nflow_save, $sflow_save, $wflow_save \n";
  }
  # Output model (state and barrier energies) for future use
  # ? state_print(); # prints states and energies ?

  if ( $n%$dprint==0 || $n==0 ) { # testing dfactor
     if ( $n==0 ) {
        $modelfolder = "models_from_run";
        system("mkdir $modelfolder");
     }
     $energyfile = $modelfolder . "\/" . "energies-$n";
     $barrierfile = $modelfolder . "\/" . "barriers-$n";
     open(ENERGY, "> $energyfile") or die "Error! Can't open energy file";
     open(BARRIER, "> $barrierfile") or die "Error! Can't open energy file";
     foreach $sa (@states) {
        $a_name = $$sa[0];
        $energy_a = $energies{$a_name};
        print ENERGY "$a_name    $energy_a\n";
     }
     foreach $transn (@barkeys) {
        print BARRIER "$transn    $ebars{$transn}\n";
        if (exists $ebars{$transn}){ #testing with ebar values instead of ebars
          #print BARRIER "$transn    $ebar_hash{$transn}\n";
          #print DEBUG "$transn    $ebar_hash{$transn}\n";
        }

        #print BARRIER "$transn    $ebar{$transn}\n"; #testing
     }
     close(ENERGY) or die "Error! Cannot close";
     close(BARRIER) or die "Error! Cannot close";
  }

  #print_energies($connected_transitions, "transitions");
  unit_test_negative_energy($connected_transitions, "transitions");

  #make graph of mc energy in 10% increments, if graphing is turned on
  # warning! graphing subroutine causes rand() to have issues
  # models from runs of different length same conditions did not match
  # if ( $n>0){  # to avoid 0 mod error
  #   if (( $n % ( $nsteps * 0.10) == 0) && ($graph == 1)){
  #     plot_mc_energies($datfile); #plots a graph of mc e vs n step
  #   }
  # }


} # End of Monte Carlo loop
close(MCFILE) or die "Error! Cannot close";
close(DATA) or die "Error! Cannot close";
close(FLOWS) or die "Error! Cannot close";
close(DEBUG) or die "Error! Cannot close";
$end_time = calc_wall_clock($start_time);
print LOG "Script runtime (s): $end_time for $nsteps steps \n";

close(LOG) or die "Error! Cannot close log";
close(CLUSTER) or die "Error! Cannot close cluster file";
close(BETA) or die "Error! Cannot close beta file";
close(BETAG) or die "Error! Cannot close beta2 file";
#automation diasbled for now

#print LOG "Running find min python script...\n";
#if ( $autobot == 1){ #run automation pipeline
#  system("python $find_min_script $alpha $seed $nsteps $analysis_type");
#}

#move datalog to new folder
close $fh_d or die "Error! Cannot close file";

#################################################################################

#### Subroutines
sub initialize_barriers { # initialize barrier energies and edges array
  my $i; my $j; my $a_name; my $b_name; my $pairname;
  my $energy_a; my $energy_b; my $emax;
  $i=0;
  foreach $sa (@states) {
     $j=0;
     #$diag[$i] = 0;
     foreach $sb (@states) {
        $a_name = $$sa[0];
        $b_name = $$sb[0];
        if ( $i<$j ) {
            $pairname = $a_name."_AND_".$b_name;
        }
        else         { # pairname INDEPENDENT of order
            $pairname = $b_name."_AND_".$a_name;
        }
        $d = distance( \@$sa, \@$sb, \@unit_lengths ); # passing references
        if ( $d==1 ) { # transitions only allowed between 'nearest-neighbor' states
           $energy_a = $energies{$a_name};
           $energy_b = $energies{$b_name};
           $emax = 0.5*(  $energy_a + $energy_b + abs( $energy_a - $energy_b ));
           #if ( $n==0 ) { # initialization step of MC - set transition state energies
              $edges[$i][$j] = 1;
              #print LOG "MC initialization ...\n";
              #print LOG "states: $$sa[0]  $$sb[0]    energies: $energy_a  $energy_b  max=$emax\n";
              if ( $i<$j ) { $ebars{$pairname} = $ebump; } # initial barrier energy
              edge_checker_in( $a_name, $b_name ); # find edges transporting S, for MC energy
              edge_checker_ion( $a_name, $b_name ); # find edges transporting N
              if ( $proof==1 ) {
                 edge_checker_tox( $a_name, $b_name ); # find edges transporting W, for MC energy
              }
              if ( $i<$j && edge_checker_slow_rev( $a_name, $b_name ) == 1 ) { # find edges with slow transitions
                 # Note subroutine depends on order, but pairname does not - so both orders must be checked
                 print LOG "Slow pair found: $pairname\n";
                 push @slowpairs, $pairname;
                 $ebars{$pairname} = $ebump + $ebarslow;
              }
           #}
        }
        else { # distance not 1, so rate is zero
           $edges[$i][$j] = 0;
        }
        $j++;
     }
     $i++;
  }
}

# Use pdl to solve matrix instead of python/numpy -7/18/17 AG
# Solves [A][X] = [B] my multiplying both side by [A] inverse matrix.
# ([A]^-1)x[X] = ([A]^-1)x[B] => [I][X] = ([A]^-1)x[B] where [I] is the identity matrix
sub call_pdl { # generate file for Python solution
  #print " calling pdl ....\n";
  my $tolerance = 1e-15;
  my $flag = 0;
  my ( $ref, $tmpfile )  = @_;
  my @alt_matrix = @{ $ref }; # dereferencing and copying each array
  my $n_alt = @alt_matrix;
  my $i; my $j;
  my $a = zeros($n_alt,$n_alt); # initializes [A] matrix to all zeros
  my $b = zeros(1,$n_alt); # initializes [B] matrix to all zeros
  my $c = zeros($n_alt,$n_alt); # initilizes [x] matrix to all zeros
  set($b,0,($n_alt-1),1); # sets bottom (last) B matrix value to 1
  # sets values of A matrix by iterating through loop
  for ( $i=0; $i<$n_alt; $i++ ) {
       for ( $j=0; $j<$n_alt; $j++ ) {
            #(1) Need diagonal as negative sum of row of K
            #(2) Need transpose K^T
            #(3) Need sum of probabilities constraint instead of one row of K^T
            set($a,$j,$i,$alt_matrix[$j][$i]);
       }
  }
  if ($n%$dprint==0 ){
    #print $fh_d "$n, " x scalar @a;
    print $fh_d "$n\n";
    #print $fh_d "\n";
    foreach my $row (@alt_matrix) {
      foreach my $element (@$row) {
        print $fh_d "$element, " ;
      }
      print $fh_d "\n";
    }
  }

  # Call pdl matrix solver function (used instead of python for better performance)
  try {
    $c = (inv($a)) x $b; # computes solutions matrix [X]  # sometimes gets an error (singular matrix or LU decomposition)!
  } catch {
    warn "$n caught call_pdl error: $_"; # not $@
    print "$n caught call_pdl error: $_"; # not $@
    $flag = 1;
  };


  # # check if answer is correct (x = A^-1 B => A = x^-1 B)
  # $d = $a x $c;  # Ax = B
  # my @comparison_matrix;
  # foreach $_ ($d->dog)
  # {
  #  push @comparison_matrix, $_;
  #  #print $_, "\n";
  # }
  # for( $i=0; $i<(scalar @comparison_matrix); $i++ ) {
  #   if ($i == (scalar @comparison_matrix) - 1){  # last entry
  #     if (abs($comparison_matrix[$i] - 1) > $tolerance ){
  #       $flag = 1;
  #       warn "matrix solution:$comparison_matrix[$i]  exceeds tolerance:$tolerance from 1\n";
  #       print "matrix solution:$comparison_matrix[$i]  exceeds tolerance:$tolerance from 1\n";
  #     }
  #   }else {
  #     if (abs($comparison_matrix[$i] - 0) > $tolerance){
  #       $flag = 1;
  #       warn "matrix solution:$comparison_matrix[$i]  exceeds tolerance:$tolerance from 0\n";
  #       print "matrix solution:$comparison_matrix[$i]  exceeds tolerance:$tolerance from 0\n";
  #     }
  #   }
  #
  # }
  #
  # if it is correct, continue
  if($flag == 0){
    open my $fh2, ">",$tmpfile or die "Error! Cannot open" ; # Open/close file and print to temporary files
    print $fh2 $c;
    close $fh2 or die "Error! Cannot close";
  } else {
    call_pdl2( \@alt_matrix, $tmpfile);  # will return python solution
  }
}


sub call_pdl2 { # generate file for Python solution

# if ($n%$dprint==0 ){
#   print $fh_d "$n, " x scalar @a;
#   print $fh_d "\n";
#   foreach my $row (@alt_matrix) {
#     foreach my $element (@$row) {
#       print $fh_d "$element, " ;
#     }
#     print $fh_d "\n";
#   }
print "$n calling python matrix solver...\n";
warn "$n calling python matrix solver...\n";
my $pyfile = "python_solver.py";
my ( $ref, $tmpfile )  = @_;
my @alt_matrix = @{ $ref }; # dereferencing and copying each array
my $n_alt = @alt_matrix;
my $i; my $j;
open(PYFILE, "> $pyfile");
print PYFILE "import numpy as np\n";
print PYFILE "np.set_printoptions(precision=16)\n";
print PYFILE "a = np.array\(\[\n";
for ( $i=0; $i<$n_alt; $i++ ) {
   print PYFILE "\[";
   for ( $j=0; $j<$n_alt; $j++ ) {
      # (1) Need diagonal as negative sum of row of K
      # (2) Need transpose K^T
      # (3) Need sum of probabilities constraint instead of one row of K^T
      print PYFILE "$alt_matrix[$j][$i]";  # note use of transpose
      unless ( $j==$n_alt-1) {
         print PYFILE ",  ";
      }
      else                    { print PYFILE "   "; }
   }
   unless ( $i==$n_alt-1) {
      print PYFILE "\],\n";
   }
   else                    {
      print PYFILE "\] \n";
   }
}
print PYFILE "])\n";
print PYFILE "b = np.array\(\[";
for ( $i=0; $i<$n_alt; $i++ ) {
   unless ( $i==$n_alt-1) {
      print PYFILE "0, ";
   }
   else                    {
      print PYFILE "1";
   }
}
print PYFILE "])\n";
print PYFILE "x = np.linalg.solve(a, b)\n";
print PYFILE "print(x)\n";
close(PYFILE);

# Call python for math
system("python $pyfile > $tmpfile");
}





sub equiv_hashes_from_list {
  my ( $ref )  = @_;
  my @equiv_lists = @{ $ref }; # dereferencing and copying each array
  my $ilist = 0; my $list; my $tmpkey; my $tmplen; my @tmplist; my $i; my $tmpstate;
  my %equiv_alt; my %samep_alt;

  foreach $list ( @equiv_lists ) {
     #print LOG "NEW Equiv array $ilist = @{$equiv_lists[$ilist]}\n";
     $tmpkey = ${$equiv_lists[$ilist]}[0];
     $tmplen = @{$equiv_lists[$ilist]};
     #print LOG "... Making a state referenced to $tmpkey with $tmplen other states\n";
     @tmplist = ();
     for ( $i=1; $i<$tmplen; $i++ ) {
        $tmpstate =  ${$equiv_lists[$ilist]}[$i];
        push @tmplist, $tmpstate;
        $equiv_alt{$tmpstate} = $tmpkey; # indicates which key a given state is referenced to
     }
     $samep_alt{$tmpkey} = [@tmplist];   # hash giving all states referenced to a key
     $ilist ++;
  }
  return (\%equiv_alt, \%samep_alt);
}

sub equiv_list_from_pairs {
  # From tied states, construct lists with same populations (second version)
  my ( $ref )  = @_;
  my @tied_states = @{ $ref }; # dereferencing and copying each array

  #print LOG "\nConstruct lists with same populations - second version\n";
  my @equiv_lists = (); # this should be array of arrays of equivalent states
  my @already = (); # list of tied pairs already linked for equivlaent states
  my $ibig = 0;
  my @tmplist;
  my $aname; my $bname; my $ilist; my $not_in; my $ial; my $list; my $tlist;
  foreach $tlist ( @tied_states ) { # now all are two element arrays
     @tmplist = ();
     $aname = $$tlist[0]; $bname = $$tlist[1];
     #print LOG "TIED PAIR: $aname  $bname\n";
     $ilist = 0;
     # possible both states already in a list even if tied pair not yet considered due to 'loops'
     $not_in = 1;
     foreach $list ( @equiv_lists ) {
        if ( grep { $aname eq $_ } @{$equiv_lists[$ilist]} ) { # just need to find one element
           # because both elements will be listed due to loop
           #print LOG "ITEMS $aname $bname FOUND in existing list\n";
           $not_in = 0;
        }
        $ilist ++;
     }
     if ( $not_in==1 ) {
     unless ( grep { $ibig eq $_ } @already ) { ################
        #print LOG "NOW CHECKING TIED PAIR $ibig: $aname  $bname\n";
        push @tmplist, ( $aname, $bname );
        push @already, $ibig;
        $ial = 0; # index for tied pairs
        foreach $list ( @tied_states ) { # loop to find other pairs matching ibig pair
           unless ( grep { $ial eq $_ } @already ) {
              $aname = $$list[0]; $bname = $$list[1];
              #print LOG "tied array $ial: $aname   $bname\n";
              if ( grep { $aname eq $_ } @tmplist ) {
                 unless ( grep { $bname eq $_ } @tmplist ) {
                    push @tmplist, $bname;
                    push @already, $ial;
                 }
              }
              if ( grep { $bname eq $_ } @tmplist ) { # note this is not
                 unless ( grep { $aname eq $_ } @tmplist ) {
                    push @tmplist, $aname;
                    push @already, $ial;
                 }
              }
              #print LOG "... Current tmplist = @tmplist\n";
              #print LOG "... Already put in equiv_lists: @already\n";
           }
           $ial ++;
        } # foreach list loop
     } # unless loop #######################
     } # if not_in
     if ( @tmplist>0 ) { push @equiv_lists, [@tmplist]; }
     $ibig ++;
  }
  return \@equiv_lists;
}

sub equiv_state { # from raw index get equivalent-state index
   my $i = $_[0];
   my $salt; my $ialt;
   my $istate = $states[$i][0]; # state name
   if ( grep { $istate eq $_ } @equivkeys_alt ) {
      $salt = $equiv_alt{$istate};
      $ialt = $alt_indices{$salt};
      #print LOG "state $i ($istate) rate assigned to alt index $ialt (state $salt)\n";
   }
   else {
      $ialt = $alt_indices{$istate};
      #print LOG "state $i ($istate) is itself an alt/ref state index $ialt\n";
   }
   return $ialt;
}

sub state_print { # print states and energies
   my $name;
   print LOG "\nSTATES AND ENERGIES\n";
   foreach $state ( @states ) {
      $name = $$state[0];
      print LOG "State $name with Energy $energies{$name}\n";
   }
   print LOG "\n";
}

sub mc_energy {
   my $epsilon = 1e-15;
   my $a; my $b; my $emc = 0.0;
   my $fflow; my $bflow;
   my $sflow = 0.0; my $wflow = 0.0; my $nflow = 0.0;
   foreach $pair ( @s_edges ) {
      $a = $$pair[0]; $b = $$pair[1];
      $fflow = flow( $a, $b );  $bflow = flow( $b, $a);
      $sflow +=  $fflow - $bflow; # negative net substrate transport targets more transport
   }
   foreach $pair ( @n_edges ) {
      $a = $$pair[0]; $b = $$pair[1];
      $fflow = flow( $a, $b );  $bflow = flow( $b, $a);
      #print LOG "mc_energy: pair $a  $b  with flows $fflow  $bflow\n";
      $nflow +=  $fflow - $bflow; # negative net substrate transport targets more transport
   }
   if ( $proof==1 ) {
      foreach $pair ( @w_edges ) {
         $a = $$pair[0]; $b = $$pair[1];
         $fflow = flow( $a, $b );  $bflow = flow( $b, $a);
         #print LOG "mc_energy: pair $a  $b  with flows $fflow  $bflow\n";
         $wflow +=  $fflow - $bflow; # negative net substrate transport targets more transport
      }
      if ($energy_function eq "symporter"){
          $emc = -$sflow*( (abs($sflow)+$epsilon)/(abs($wflow)+$epsilon) )**$alpha; #symporter
          print LOG "$emc = -$sflow*( (abs($sflow)+$epsilon)/(abs($wflow)+$epsilon) )**$alpha\n";
      }
      elsif ($energy_function eq 'antiporter'){
          $emc = $sflow*( (abs($sflow)+$epsilon)/(abs($wflow)+$epsilon) )**$alpha; #antiporter
      }
      else {$emc = -$sflow;}
      print LOG "\nmc_energy = $emc  S flow = $sflow    W flow = $wflow    N flow = $nflow (for current trial)\n\n";
   }
   else {  # not proofreading
     if ($energy_function eq "symporter"){
       $emc = -$sflow; #symporter
     }
     elsif ($energy_function eq 'antiporter'){
       $emc = $sflow; #antiporter
     } else {$emc = -$sflow;}
   }
   return ( $emc, $sflow, $wflow, $nflow );
}

sub flow_alt {
   # single direction flux from a to b: p_a * k_ab
   my ($aname, $bname) = @_;
   my $i_a = $alt_indices{$aname};
   my $i_b = $alt_indices{$bname};
   my $pa = $alt_pss[$i_a];
   my $kab = $alt_rates[$i_a][$i_b];
   #print LOG "flow from $aname = state $i_a  to $bname = state $i_b\n";
   #print LOG "prob_a = $pa   k_ab = $kab\n";
   return $pa*$kab;
}

sub flow {
   # single direction flux from a to b: p_a * k_ab
   my ($aname, $bname) = @_;
   my $i_a = $indices{$aname};
   my $i_b = $indices{$bname};
   my $pa = $pss[$i_a];
   my $kab = $rates[$i_a][$i_b];
   return $pa*$kab;
}

sub edge_checker_ion {
   # check whether edge from a to b leads to transport to inside: add to list @n_edges
   # use unit states encoded in $ionfwd[0] and $ionfwd[1]
   my ($aname, $bname) = @_;
   #print LOG "Checker: $aname  $bname\n";
   if (  $aname =~ /$ionfwd[0]/  && $bname =~ /$ionfwd[1]/  ) {
      #print LOG "... Checker found ordered match\n";
      push @n_edges, [ $aname, $bname ];
   }
}

sub edge_checker_in {
   # check whether edge from a to b leads to transport to inside: add to list @s_edges
   # use unit states encoded in $goals[0] and $goals[1]
   my ($aname, $bname) = @_;
   #print LOG "Checker: $aname  $bname\n";
   if (  $aname =~ /$goals[0]/  && $bname =~ /$goals[1]/  ) {
      #print LOG "... Checker found ordered match\n";
      push @s_edges, [ $aname, $bname ];
   }
}

sub edge_checker_tox { # examine "toxin" = W
   # check whether edge from a to b leads to transport to inside: add to list @w_edges
   # use unit states encoded in $not_goals[0] and $not_goals[1]
   my ($aname, $bname) = @_;
   #print LOG "Checker: $aname  $bname\n";
   if (  $aname =~ /$not_goals[0]/  && $bname =~ /$not_goals[1]/  ) {
      #print LOG "... Checker found ordered match\n";
      push @w_edges, [ $aname, $bname ];
   }
}

sub edge_checker_slow_rev {
   # check whether edge from a to b is slow - e.g., unbinding to outside in IF conformation
   # order of a and b does not matter (fixing previous bug)
   # use info encoded in @slowies array
   my ($aname, $bname) = @_;
   my $conf; my $init; my $targ; my $atmp; my $btmp;
   my $slow = 0;
   my @init_list; my @targ_list;
   my $init_yes_ab = 0; my $init_targ_ab = 0;
   my $init_yes_ba = 0; my $init_targ_ba = 0;

   #print LOG "\nSlow Checker: $aname  $bname\n";
   foreach $list ( @slowies ) {
      $conf = $$list[0]; $init = $$list[1]; $targ = $$list[2];
      if (  $aname =~ /$conf/  &&  $bname =~ /$conf/  ) {
         #print LOG "... Checking  $init  and  $targ\n";
         @init_list = split /-/, $init;
         @targ_list = split /-/, $targ;
         #print LOG "... Checking conformation $conf\n";
         $init_yes_ab = all_in( \@init_list, $aname );
         $targ_yes_ab = all_in( \@targ_list, $bname );
         $init_yes_ba = all_in( \@init_list, $bname );
         $targ_yes_ba = all_in( \@targ_list, $aname );
         if (  $init_yes_ab*$targ_yes_ab==1  ||  $init_yes_ba*$targ_yes_ba==1  ) { $slow = 1; }
      }
   }

   return $slow;
}

sub edge_checker_slow { # this function no longer used - but is there a typo below
   # check whether edge from a to b is slow - e.g., unbinding to outside in IF conformation
   # use info encoded in @slowies array
   my ($aname, $bname) = @_;
   my $conf; my $init; my $targ; my $atmp; my $btmp;
   my @apieces = split /-/, $aname;
   my @bpieces = split /-/, $bname;
   my $slow = 0;

   foreach $list ( @slowies ) {
   #print LOG "\nFast Checker: $aname  $bname\n";
      $conf = $$list[0]; $init = $$list[1]; $targ = $$list[2];
      #print LOG "... Checking conformation $conf\n";
      if (  $aname =~ /$conf/  && $bname =~ /$conf/  ) {
         #print LOG "... Checker found match\n";
         for ( $jj=0; $jj<@apieces; $jj++ ) {
            $atmp = $apieces[$jj];
            $btmp = $bpieces[$jj];
            if (  $atmp =~ /$init/ && $btmp =~ /$targ/  ||  $atmp =~ /$init/ && $btmp =~ /$targ/  ) {
               #############  TYPO HERE? forgot to switch a and b above?  Probably not important
               #print LOG "... FOUND A SLOW PAIR: $aname  $bname\n";
               $slow = 1;
            }
         }
      }
   }

   return $slow;
}

sub is_binding { # checks whether the transition involves binding
   # check whether edge from a to b is slow - e.g., unbinding to outside in IF conformation
   # use info encoded in @slowies array
   my ($aname, $bname) = @_;
   my $conf; my $init; my $targ; my $atmp; my $btmp;
   my @apieces = split /-/, $aname;
   my @bpieces = split /-/, $bname;
   my $yes = 0; my $agree_sum = 0; my $idis;
   my $i; my $j;

   for ( $i=0; $i<@apieces; $i++ ) {
      if ( $apieces[$i] eq $bpieces[$i] ) { $agree_sum += 1; }
      else { $idis = $i; }
   }
   if ( $agree_sum=@apieces-1 && $bpieces[$idis] =~ /b/ ) { $yes = 1; }
   return $yes;
}

sub adjust_tied_barriers {
   my $bar = shift(@_);
   my $energy = shift(@_);
   my $key = $equiv_tr{$bar};
   if ( grep { $bar eq $_ } @dups_tr ) {
      #print MCFILE "\nEquivalents for transition $bar refd to $key\n";
      #print MCFILE "... Changing ebar of $key to $energy\n";
      $ebars{$key} = $energy; # because key itself not included in hashed array
      foreach $x ( @{$same_bar{$key}} ) {
         #print MCFILE "... Changing ebar of $x to $energy\n";
         $ebars{$x} = $energy;
      }
   }
}

### Bottleneck (only need to run once)
sub distance {
    # the sum of element-wise differences between states,
    # accounting for adjacency of first and last elements in a cycle (unit)
    my ($one_ref, $two_ref, $len_ref) = @_;
    my @one = @{ $one_ref };       # dereferencing and copying each array
    my @two = @{ $two_ref };
    my @lens = @{ $len_ref };
    my $dum = shift(@one);  $dum = shift(@two);
    my $i; my $x; my $dist = 0;
    my @diffs = ();
    for ( $i=0; $i<@one; $i++ ) { # make array of unit distances
       $x = abs($two[$i] - $one[$i]);
       #if ( $x == $lens[$i]-1 ) { $x = 1; }
        # first and last elements are neighbors in a cycle
       $diffs[$i] = $x;
       $dist += $x;
    }
    #print LOG "**dist:     @one    @two      diffs = @diffs    lens=@lens   total dist = $dist\n";
    return $dist;
}

sub all_in {
    # checks whether all elements of an array (subset of unit names)
    # are part of a string (state name)
    my ($one_ref, $name) = @_;
    my @items = @{ $one_ref };       # dereferencing and copying array
    my $test = 1;
    foreach $item ( @items ) {
        #print LOG "ALL IN: checking whether $item is in $name\n";
        unless ($name =~ /$item/) {
            $test = 0;
            #print LOG "item $item not found in name $name\n";
        }
    }
    #print LOG "ALL IN: test = $test\n";
    return $test;
}

sub pieces {
    # takes a state and returns a list of the names of each unit's state
    my ($one_ref) = @_;
    my @one = @{ $one_ref };       # dereferencing and copying each array
    my $state_name = $one[0];
    my @pieces = split /-/, $state_name;
    #print LOG "state_name = $state_name  pieces = @pieces\n";
    return \@pieces;
}

sub energy_noneq {
    # takes a state name and returns the energy by summing terms
    my ($one_ref) = @_;
    my @one = @{ $one_ref };       # dereferencing and copying each array
    my $state_name = $one[0];
    my @pieces = split /-/, $state_name;
    my $all_defined = 1;
    my $sum = 0;
    my $en_allo;
    foreach $piece ( @pieces ) {
        #print LOG "  piece = $piece\n";
        if ( defined $energy_terms{$piece} ) { $sum += $energy_terms{$piece}; }
        #else {
            #$all_defined = 0;
            #print LOG "*****\nERROR: The unit $piece in state $state_name";
            #print LOG " has no energy associated with it\n*****\n";
        #}
        #print LOG "energy for $piece = $energy_terms{$piece}\n";
    }
    #print LOG "state_name = $state_name  pieces = @pieces\n";
    # check allosteric terms
    #print LOG "ENERGY: check allosteric terms\n";
    foreach $allo ( keys %allostery_terms ) {
        @allos = split /-/, $allo;
        #print LOG "checking allos @allos in $state_name\n";
        if ( all_in( \@allos, $state_name ) ) {
            $en_allo = $allostery_terms{$allo};
            #print LOG "ENERGY: Found @allos in $state_name ... Adding $en_allo\n";
            $sum += $en_allo;
        }
    }
    #if ( $all_defined == 1 ) { return $sum; }
    #else { return "bunk"; }
    return $sum;
}

# Debug subroutine to be used as needed.
sub debug {

}

# exports nxn matrix [] to csv file
sub matrix_to_csv {
  my @matrix_to_export = @{$_[0]};
  my $matrix_file_name = $_[1];
  my $n_dim = $_[2];
  my @n_labels = @{$_[3]};

  open(MATRIX_CSV, "> $matrix_file_name") or die "cannot open file for matrix to csv";
  for ($i = 0; $i < $n_dim; $i++){
      if ($i==0){
        print MATRIX_CSV " , $n_labels[$i], ";
      }
      elsif ($i < $n_dim && $i >= 1){
          print MATRIX_CSV "$n_labels[$i], ";
      }
    }
  print MATRIX_CSV "\n";
  for ($i = 0; $i < $n_dim; $i++){
      print MATRIX_CSV "$n_labels[$i], ";
    for ($j = 0; $j < $n_dim; $j++ ){
        print MATRIX_CSV "$matrix_to_export[$i][$j], " ;
    }
  print MATRIX_CSV "\n";
  }
  close(MATRIX_CSV) or die "Error! Cannot close";
}

#this script loads in adjacency matrix (in .csv format)from proof-maker
#then it converts the matrix to graph then to sub matrices to use in proof-maker
sub python_networkx {

    system("python $pythonfile");

};

sub import_from_python {
    my $state_filename = "python_to_perl_state";
    my $transition_filename = "python_to_perl_transition";

    open my $fh2, "<", "$state_filename" or die "Could not open file '$state_filename' ";
    my $state_consistency_flag = <$fh2>;
    print LOG "state consistency $state_consistency_flag\n";
    #print DEBUG "state consistency $state_consistency_flag\n";
    close $fh2 or die "Error! Cannot close";

    open $fh2, "<", "$transition_filename" or die "Could not open file '$transition_filename' ";
    my $transition_consistency_flag = <$fh2>;
    print LOG "transition consistency $transition_consistency_flag\n";
    #print DEBUG "transition consistency $transition_consistency_flag\n";
    close $fh2 or die "Error! Cannot close";

    my $json_state;
    my $json_transition;

    local $/; #Enable 'slurp' mode
    open my $fh, "<", "$state_filename.json" or die "Can't open file!";
    $json_state = <$fh>;
    close $fh or die "Error! Cannot close";

    open $fh, "<", "$transition_filename.json" or die "Can't open file!";
    $json_transition = <$fh>;
    close $fh or die "Error! Cannot close";

    my $json_ref_state_data = decode_json($json_state);#returns REFERENCES
    my $connected_states_ref = $json_ref_state_data; #copy of hash references to be used in other sub routines
    my %json_deref_state_data = %{$json_ref_state_data};#dereference

    my $json_ref_transition_data = decode_json($json_transition);#returns REFERENCES
    my $connected_transitions_ref = $json_ref_transition_data; #copy of hash references to be used in other sub routines
    my %json_deref_transition_data = %{$json_ref_transition_data};#dereference


    return $connected_states_ref, $connected_transitions_ref;
}

sub initial_model {
  my $connected_states_ref2 = $_[0]; # $connected_states_ref is declared in sub import_from_python
  my $connected_transitions_ref2 = $_[1]; # not being used currently, energies are assigned previously in program, python used to check consistency

  my %connected_states_deref = %{$connected_states_ref2};
  my %connected_transitions_deref = %{$connected_transitions_ref2};

  print LOG "intializing state energies model ...\n";
  foreach $key (keys %connected_states_deref){
    foreach $key_in_key (keys %{$connected_states_deref{$key}}){
       $energies{$key_in_key} = $connected_states_deref{$key}{$key_in_key};
    }
  }

  print LOG "initializing transition energies model with energies = ebump ($ebump) or ebump + ebarslow ($ebump+$ebarslow) 100 (if a slow transition)\n";
  foreach $key (keys %connected_transitions_deref){
    foreach $key_in_key (keys %{$connected_transitions_deref{$key}}){
      if (grep { $key_in_key eq $_ } @slowpairs){
          print LOG "transition $key_in_key is in slowies. Set energy = $ebarslow + $ebump\n";
          $connected_transitions_deref{$key}{$key_in_key} = $ebarslow + $ebump;
          $ebars{$key_in_key} = $ebarslow + $ebump;
      } else{
          print LOG "transition $key_in_key is NOT in slowies. Set energy = $ebump\n";
          $connected_transitions_deref{$key}{$key_in_key} = $ebump;
          $ebars{$key_in_key} = $ebump;
      }
      #print transitions and barriers for initial model...

    }
  }

  print LOG "model has been initialized!\n";
}

sub adjust_tied_barriers2 { # takes in perturbed_state, connected_states_ref, and energy_pertubation
  my $perturbed_barrier = $_[0];
  my $connected_barriers_ref = $_[1];
  my $barrier_energy_value = $_[2];
  my %connected_barriers_deref = %{$connected_barriers_ref};
  print LOG "perturbed_state: $perturbed_barrier \n";
  #search for connected subgraph of perturbed state
  #search 1st level for match
  foreach $key (keys %connected_barriers_deref){
    foreach $key_in_key (keys %{$connected_barriers_deref{$key}}){
      if ($key_in_key eq $perturbed_barrier){
          foreach $key_in_key (keys %{$connected_barriers_deref{$key}}){
            $connected_barriers_deref{$key}{$key_in_key} = $connected_barriers_deref{$key}{$key_in_key} + $barrier_energy_value;
            $ebars{$key_in_key} = $connected_barriers_deref{$key}{$key_in_key};
          }
      }
    }
  }
}

sub adjust_tied_energies2 { # takes in perturbed_state, connected_states_ref, and energy_pertubation
  my $perturbed_state = $_[0];
  my $connected_states_ref = $_[1];
  my $state_energy_value = $_[2];
  my %connected_states_deref = %{$connected_states_ref};
  print LOG "perturbed_state: $perturbed_state \n";
  foreach $key (keys %connected_states_deref){
    foreach $key_in_key (keys %{$connected_states_deref{$key}}){
      if ($key_in_key eq $perturbed_state){
          foreach $key_in_key (keys %{$connected_states_deref{$key}}){
            $connected_states_deref{$key}{$key_in_key} = $connected_states_deref{$key}{$key_in_key} + $state_energy_value;
            $energies{$key_in_key} = $connected_states_deref{$key}{$key_in_key};
          }
      }
    }
  }
}

sub load_config_settings {
  my $config_file = $_[0]; #load config file
  print "using config file: $config_file\n";
  my %default_parameters = (   # default parameter values
    proof => 0,#proofreading is turned off by default
    na_first => 0,
    nsteps => 1e4,
    dprint => 1e0,
    n_beta => 1,
    seed => 456789,
    demax => 1.0,
    alpha => 0.0,
    fbeta => 1e3,
    tol => 0.3,
    pbeta_stay => 0.2,
    dmu_N => -4,
    dmu_S => 2,
    dmu_W => 2,
    fmu_N => 0.5,
    fmu_S => 0.5,
    fmu_W => 0.5,
    ebarslow => 99,
    kzero => 1e-3,
    ebump => 1.0,
    tmpfile => "prob_ss.dat",
    mcfile => "mc_out.dat",
    kfile => "rate_matrix.tmp",
    datfile => "evolver_rates.dat",
    flowfile => "evolver_flows.dat",
    debugfile => "debug",
    logfile => "logfile",
    directory => "RUN_1",
    autobot => "0", #for automation, currently disabled
    dg_sw => 0,
    Sb_Wb_tied => 0,
    energy_function => "symporter",
    graph => 1,
    b_min => 1e1,
    b_max => 1e30,
    temp_scale => 1.0,
  );
  my @required_parameters = ( # Required paramters to be in config file
    "proof", "na_first", # Simulation Parameters
    "nsteps","dprint","n_beta","seed","demax","alpha","fbeta","tol","pbeta_stay", # Monte Carlo Parameters
    "dmu_N","dmu_S","dmu_W","fmu_N","fmu_S","fmu_W","ebarslow","kzero","ebump", # Physical Parameters
    "tmpfile", "mcfile", "kfile", "datfile", "flowfile", "debugfile", "logfile", # output files
    "directory", #new directory for run
    "autobot", #turn on/off automation pipeline (currently disabled)
    "dg_sw", # set dg_sw (different binding energy of W to S)
    "Sb_Wb_tied", # controls how "tied together Sb and Wb are"
    "energy_function", #which energy function to use (i.e. for symport or antiport)
    "graph", #graphs mc energy automatically
    "b_min", "b_max", # min, max beta values
    "temp_scale", # scaling factor for manual tempering schedule
  );
  my %config;
  Config::Simple->import_from( $config_file, \%config);
  for (@required_parameters ) {  # Verify
    print "Parameter '$_' is missing from config. Using default value = $default_parameters{$_}\n" unless exists $config{$_};
  }
  my %settings = (%default_parameters, %config );
  #print LOG "settings: \n". Dumper(%settings)."\n";
  return %settings;
}

#not used because some equivalent lists have members with different values
#inputs: list of equivalent states and energies
#outputs: boolean flag
#check if tied states have same energies and outputs true if they do.
sub unit_test_tied_list{
  $connected_list_ref = $_[0];
  my $list_label = $_[1];
  my %connected_list_deref = %{$connected_list_ref};
  my $test_energy = 0;
  my $test_energy2 = 0;
  my $test_fail_flag = 0;
  #check for energy equivalence
  foreach $key (keys %connected_list_deref){
     foreach $key_in_key (keys %{$connected_list_deref{$key}}){
         $test_energy = $connected_list_deref{$key}{$key_in_key};
         foreach $key_in_key2 (keys %{$connected_list_deref{$key}}){
           $test_energy2 = $connected_list_deref{$key}{$key_in_key2};
           if (abs($test_energy- $test_energy2) > 0.00001) {
             $test_fail_flag = 1;
             #print DEBUG "TEST FAILED! $list_label connected list is not equivalent. \n";
             #print DEBUG "key = $key, key_in_key = $key_in_key, key_in_key2 = $key_in_key2\n";
             #print DEBUG "energy = $test_energy, energy2 = $test_energy2 \n";
           }
         }
     }
  }
  if ($test_fail_flag == 1){
    print LOG "Failed unit test. Energies in $list_label connected list are NOT equivalent!\n";
    #print DEBUG "Failed unit test. Energies in $list_label connected list are NOT equivalent!\n";
    Win32::MsgBox("$list_label Failed unit test. Energies in tied list not equivalent! See log for details.");
    exit;
  } else {
    print LOG "Passed unit test. Energies in $list_label connected list are equivalent!\n";
    #print DEBUG "Passed unit test. Energies in $list_label connected list are equivalent!\n";
  }

}

#used to check if energies before/after are the same
sub unit_test_check_restored_energies {
  my $dictionary1_ref = $_[0];
  my $dictionary2_ref = $_[1];
  my $test_label = $_[2];
  my %dictionary1_deref = %{$dictionary1_ref};
  my %dictionary2_deref = %{$dictionary2_ref};
  my $test_fail_flag = 0;

  foreach $key (keys %dictionary1_deref){
     foreach $key_in_key (keys %{$dictionary1_deref{$key}}){
         if ( abs($dictionary1_deref{$key}{$key_in_key} - $dictionary2_deref{$key}{$key_in_key}) >0.00001) { #check if equal within tolerance
           $test_fail_flag = 1;
           #print DEBUG "TEST FAILED! $test_label\n";
           #print DEBUG "key = $key, key_in_key = $key_in_key\n";
           #print DEBUG "$dictionary1_deref{$key}{$key_in_key} != $dictionary2_deref{$key}{$key_in_key}\n";
         }
     }
  }
  if ($test_fail_flag == 1){
    print LOG "Failed unit test. Energies are NOT restored. $test_label\n";
    #print DEBUG "Failed unit test. Energies are NOT restored. $test_label \n";
    Win32::MsgBox("$test_label Failed unit test. Energies have not been restored! See log for details.");
    exit;
  } else {
    print LOG "Passed unit test. Energies are restored. $test_label\n";
    #print DEBUG "Passed unit test. Energies are restored. $test_label\n";
  }
}

sub print_energies {
  my $energy_dictionary_ref = $_[0];
  my $energy_label = $_[1];
  my %energy_dictionary_deref = %{$energy_dictionary_ref};

  #print DEBUG "Printing Energies for $energy_label...\n\n";

  foreach $key (keys %energy_dictionary_deref){
     #print DEBUG "key = $key\n";
     foreach $key_in_key (keys %{$energy_dictionary_deref{$key}}){
         #print DEBUG "key = $key_in_key value = $energy_dictionary_deref{$key}{$key_in_key} \n";
     }
     #print DEBUG "\n";
  }
  print LOG "\n";
}

# This tests that tied energies have the same difference after a trial move
# (i.e. tied energy groupings remain with fixed landscape)
sub unit_test_tied_energy_difference {
  my $dictionarya_ref = $_[0];
  my $dictionaryb_ref = $_[1];
  my $test_label = $_[2];
  my $tied_energy_difference = 0;
  my %dictionarya_deref = %{$dictionarya_ref};
  my %dictionaryb_deref = %{$dictionaryb_ref};
  my $test_fail_flag = 0;

  foreach $key (keys %dictionaryb_deref){
     $tied_energy_difference = $dictionaryb_deref{$key}{$key} - $dictionarya_deref{$key}{$key}; #could also use $delta_e
     foreach $key_in_key (keys %{$dictionaryb_deref{$key}}){
         if ( abs( ($dictionaryb_deref{$key}{$key_in_key} - $dictionarya_deref{$key}{$key_in_key}) - ($tied_energy_difference) > 0.00001 ) ) {# check if equal within tolerance
           $test_fail_flag = 1;
           #print DEBUG "TEST FAILED! $test_label\n";
           #print DEBUG "key = $key, key_in_key = $key_in_key\n";
           #print DEBUG "(E after) $dictionaryb_deref{$key}{$key_in_key} - (E before) $dictionarya_deref{$key}{$key_in_key} != $tied_energy_difference \n";
         }
     }
   }
     if ($test_fail_flag == 1){
       print LOG "Failed unit test. Energy differences are NOT equal. $test_label\n";
       #print DEBUG  "Failed unit test. Energy differences are NOT equal. $test_label\n";
       Win32::MsgBox("$test_label Failed unit test. Tied energy groupings have changed fixed values!See log for details.");
       exit;
     } else {
       print LOG "Passed unit test. Energy differences are equal. $test_label\n";
       #print DEBUG  "Passed unit test. Energy differences are equal. $test_label\n";
     }

}

sub unit_test_negative_energy {
  my $dictionary_ref = $_[0];
  my $test_label = $_[1];
  my %dictionary_deref = %{$dictionary_ref};
  my $test_fail_flag = 0;

  foreach $key (keys %dictionary_deref){
     foreach $key_in_key (keys %{$dictionary_deref{$key}}){
         if ($dictionary_deref{$key}{$key_in_key} < 0) {
           $test_fail_flag = 1;
           #print DEBUG "TEST FAILED! $test_label\n";
           #print DEBUG "key = $key, key_in_key = $key_in_key\n";
           #print DEBUG "$dictionary_deref{$key}{$key_in_key} < 0\n";
         }
     }
   }
   if ($test_fail_flag == 1){
     print LOG "Failed unit test. Energy < 0.  $test_label\n";
     #print DEBUG  "Failed unit test. Energy < 0.  $test_label\n";
     Win32::MsgBox("$test_label Failed unit test. Energy < 0. See log for details.");
     exit;
   } else {
     print LOG "Passed unit test. Energy > = 0. $test_label\n";
     #print DEBUG  "Passed unit test. Energy  > = 0. $test_label\n";
   }

}

sub set_reference_state {
  my ( $dictionary_ref, $top_level_key) = @_; #need to use top level key value (not key of key) to avoid searching through hash
  my %dictionary_deref = %{$dictionary_ref};
  my @dictionary_keys = keys %dictionary_deref;
  my @reference_connected_list = ();
  my $key = '';

  if (defined $top_level_key && exists $dictionary_deref{$top_level_key}){
     $key = $top_level_key;
     #print DEBUG "$key is a top level key in the dictionary and will be the reference key.\n";
  } else {
     $key = @dictionary_keys[rand @dictionary_keys];
     print DEBUG "random state chosen to be reference key = $key\n";
  }

  foreach $key_in_key (keys %{$dictionary_deref{$key}}){
      push @reference_connected_list, $key_in_key;
   }
  return @reference_connected_list;
}

# WARNING! this has caused issues w/ random number generation!
# could be using system call to affect rand()/srand()?? need to test
#plots mc_energies using chart::gnuplot module
sub plot_mc_energies {

  my $sub_datafile = $_[0]; #evolver_rates.dat by default
  #my $current_time = calc_wall_clock($start_time);

  #make a new chart. note that gnuplot path needs to be specified in Windows
  my $chart = Chart::Gnuplot->new(
    output => "mc_energy_trajectory.png",
    gnuplot => "C:\\Program Files\\gnuplot\\bin\\gnuplot.exe",
    terminal => 'png',
    title  => "MC Energy Trajectory",
    timestamp => "on",
    xlabel => "n step",
    ylabel => "MC Energy",
  );
  #data set to be plotted
  my $data_set = Chart::Gnuplot::DataSet->new(
      datafile => "$sub_datafile",
      style => "lines",
  );

  # Plot the graph
  $chart->plot2d($data_set);
}

# Caculates and prints script runtime in seconds
sub calc_wall_clock {
  my $start_time = $_[0];
  my $end_time = time();
  my $run_time = $end_time - $start_time;
  return $run_time;
}

sub avg_emc {
  $old_dmu = $dmu_N;
  $dmu_fin = -2;
  $dmu_init = -6;
  $n_inc = 10;
  $analysis = "vary_dmu_N";
  $dmu_inc = ( $dmu_fin - $dmu_init ) / $n_inc;
  #$emc_total = 0;
  @emc_data = ();
  # save old data to restore

  for ($count=0; $count<$n_inc+1; $count++){
    if ($count == $n_inc){
      $dmu_now = $old_dmu;  # reset
    } else {
      $dmu_now = $dmu_init + $count*$dmu_inc;
    }
    if ( $analysis eq "vary_dmu_N" ) {  # update energy terms
       print LOG "\nAnalysis type: $analysis\n";
       $dmu_N = $dmu_now;
       $energy_terms{'No'} = -$fmu_N*$dmu_N;
       $energy_terms{'Ni'} = (1-$fmu_N)*$dmu_N; # Note that 1 - fmu_N -(-fmu_N) = 1
       foreach $key ( keys(%energy_terms) ) { print LOG "energy_term $key = $energy_terms{$key}\n"; }
    }
    foreach $state (@states) {  # update non-equilibrium energies for each state
       $name = $$state[0];
       $energies_noneq{$name} = energy_noneq( \@$state );
       print LOG "State name and indices: @$state   E_noneq = $energies_noneq{$name}\n";
    }

    %ebar_hash = (); #testing
    $i=0;
    foreach $sa (@states) {
       $j=0;
       $diag[$i] = 0;
       foreach $sb (@states) {
          $a_name = $$sa[0];
          $b_name = $$sb[0];
          if ( $i<$j ) {
              $pairname = $a_name."_AND_".$b_name;
          }
          else         { # pairname INDEPENDENT of order
              $pairname = $b_name."_AND_".$a_name;
          }
          $d = distance( \@$sa, \@$sb, \@unit_lengths ); # passing references
          if ( $d==1 ) { # transitions only allowed between 'nearest-neighbor' states
             $energy_a = $energies{$a_name};
             $energy_b = $energies{$b_name};
             $ddmu = 0.0;
             if ( is_binding( $a_name, $b_name ) ) { # rate adjustments based on ligand concentration - binding only
                $dmu_a = $energies_noneq{$a_name}; # log of concentration diff of a vs. equil
                $dmu_b = $energies_noneq{$b_name}; # log of concentration diff of a vs. equil
                $ddmu = $dmu_a - $dmu_b;
                #print LOG "New rate: ddmu = $ddmu    $a_name  =>  dmu_a = $dmu_a  ...  $b_name => dmu_b = $dmu_b\n";
             }
             $emax = 0.5*(  $energy_a + $energy_b + abs( $energy_a - $energy_b ));
             $ebar = $emax + $ebars{$pairname}; # transition state energy
             $ebar_hash{$pairname} = $ebar; #TESTING
             $rateij = exp( $ddmu ) * $kzero * exp( -( $ebar - $energy_a ) ); # simple Arrhenius rate * ligand conc
          }
          else { # distance not 1, so rate is zero
             $rateij = 0.0;
             $edges[$i][$j] = 0;
          }
          $rates[$i][$j] = $rateij;
          $matrix[$i][$j] = $rates[$i][$j]; # what will actually be used to solve
          $diag[$i] -= $rateij;
          $j++;
       }
       $matrix[$i][$i] = $diag[$i];
       $rates[$i][$i] = $diag[$i];
       $matrix[$i][@states-1] = 1; # for probability constraint
       $i++;
    }

    ### Make alternative rate matrix needed to find populations
    #print LOG "\nConstructing alt_rates matrix\n";
    for ( $i=0; $i<$n_alt; $i++ ) { # zero out rates because they're re-summed each MC step
       for ( $j=0; $j<$n_alt; $j++ ) {
          $alt_rates[$i][$j] = 0.0;
       }
    }
    # sum over all rates from equivalent states
    for ( $i=0; $i<$nstates; $i++ ) { # run through original indices
       $ialt = equiv_state($i);
       for ( $j=0; $j<$nstates; $j++ ) {
          $jalt = equiv_state($j);
          #print LOG "Making new matrix states $i = $istate and $j = $jstate\n";
          unless ( $i==$j) { $alt_rates[$ialt][$jalt] += $rates[$i][$j]; }
       }
    }
    # add diagonal elements
    for ( $i=0; $i<$n_alt; $i++ ) { # zero out rates because they're re-summed each MC step
       $sum = 0.0;
       for ( $j=0; $j<$n_alt; $j++ ) {
          unless ( $i==$j) { $sum -= $alt_rates[$i][$j]; }
       }
       $alt_rates[$i][$i] = $sum;
    }
    # print the alt rates matrix and define the matrix for solution
    #print LOG "\n\nPresenting the alternate rate matrix ....\n";
    for ( $i=0; $i<$n_alt; $i++ ) { # zero out rates because they're re-summed each MC step
       for ( $j=0; $j<$n_alt; $j++ ) {
          #printf("%5.2e  ", $alt_rates[$i][$j]);
          if ( $j < $n_alt-1 ) {
             $alt_matrix[$i][$j] = $alt_rates[$i][$j];
          }
       }
       $alt_matrix[$i][$n_alt-1] = 1; # for probability constraint
       #print LOG "\n";
    }
    #print LOG "\n\n";


    # write rates file for inspection
    open(KFILE, "> $kfile") or die "Error! Cannot open";
    for ( $i=0; $i<@states; $i++ ) {
       for ( $j=0; $j<@states; $j++ ) {
          printf KFILE "%8.4e  ", $rates[$i][$j];
          #printf DEBUG "%8.4e  ", $rates[$i][$j];
       }
       print KFILE "\n\n";
    }
    close(KFILE) or die "Error! Cannot close";


    # Call pdl matrix solver function (used instead of python for better performance)
    call_pdl( \@alt_matrix, $tmpfile);  # carefull! could error out

    # retrieve steady-state probabilities for alt states
    @alt_pss = ();
    open(TMP, "$tmpfile") or die "Error! Cannot open";
    while (<TMP>) {
       $_ =~ s/\[/ /;
       $_ =~ s/\]/ /;
       @vals = split ' ', $_;
       #print LOG "reading line in tmpfile: @vals\n";
       foreach $val ( @vals ) {
          $x = 1.0*$val;
          push @alt_pss, $x;
       }
    }
    print LOG "steady state values: @alt_pss\n\n";
    close(TMP) or die;

    # assign steady-state probabilities to all states
    @pss = ();
    $count = 0;
    for ( $i=0; $i<$nstates; $i++ ) { # run through original indices
       $ialt = equiv_state($i); # index of reference state with same prob
       $pss[$i] = $alt_pss[$ialt];
       #print LOG "State $i inherits prob $alt_pss[$ialt] from state $ialt\n";
       if ($pss[$i] == 0){
          $count += 1;
       }
    }
    if ($count == scalar @pss) {
       print LOG "Error in solving rate matrix: all SS probabilities = 0\n";
       print "Error in solving rate matrix: all SS probabilities = 0\n";
       exit;
    }


    @energy_info = mc_energy ();

    if ($count != $n_inc){  # don't count reset value
      @emc_data[$count] = $energy_info[0];  # keep track of all emc data points
    }

  }
  $emc_average = statistics(\@emc_data, 3);
  #print DEBUG "using emc average = $emc_average\n";
  return $emc_average;

}

sub statistics {
  my $data_ref = $_[0];
  my $select = $_[1]; #use to select type of statistics (i.e. averaging)
  my @data = @{$data_ref};

  if ($select == 1){
    #print DEBUG "using geo avg\n";
    $geo_avg = geometric_avg($data_ref);
    return $geo_avg;
  } elsif ($select == 2){
    #print DEBUG "using modified arith avg\n";
    $avg = modified_avg($data_ref);
    return $avg;
  } elsif ($select == 3){
    #print DEBUG "using median\n";
    $avg = data_median($data_ref);
    return $avg;
  } elsif ($select == 4){
    #print DEBUG "using tanh\n";
    $avg = tanh_avg($data_ref);
    return $avg;
  } else {
    #print DEBUG "using arith avg";
    $avg = arithmentic_avg($data_ref);
    ($var, $std_dev) = var_std($data_ref,$avg);
    return $avg;
  }


}

sub arithmentic_avg {
  my $data_ref = $_[0];
  my @data = @{$data_ref};
  my $total_sum = 0;
  my $N = scalar @data;
  # arithmentic mean
  for $val (@data){
      $total_sum = $total_sum + $val;
  }
  $avg = $total_sum/$N;
  return $avg;
}

sub geometric_avg {
  my $data_ref = $_[0];
  my @data = @{$data_ref};
  my $geo_prod = 1;
  my $N = scalar @data;
  my $neg_count = 0;
  # geometric mean
  for $val (@data){
      #print DEBUG "val = $val geo_prod = $geo_prod\n";
      if ($val < 0){
        $neg_count = $neg_count + 1;
      }
      $geo_prod = $geo_prod*$val;
      #print DEBUG "geo_prod after = $geo_prod \n";
  }
  $geo_avg = $geo_prod**(1/$N);
  if ($neg_count >= $N/2 || $geo_prod < 0){
    #print DEBUG "all negative!\n";
    $geo_avg = -1*$geo_avg;
  }
  return $geo_avg;
}

sub var_std {
  my $data_ref = $_[0];
  my $avg = $_[1];
  my @data = @{$data_ref};
  $N = scalar @data;
  $var_sum = 0;

  for $val (@data){
    $var_sum = $var_sum + (($val - $avg)**2);
  }
  $var = $var_sum/$N;
  $std_dev = $var**(0.5);
  return $var, $std_dev;

}

# inputs an array (ref) of numbers, outputs a log arithmetic average
sub modified_avg {
  my $data_ref = $_[0];  # data array reference
  my @data = @{$data_ref};  # de-reference array
  my $N = scalar @data;  # number of items in array
  my $sum = 0;

  for $val (@data){
    #print DEBUG "val = $val\n";  # for debugging
    $sum = $sum + (sign($val) * (log(abs($val))));  # keep sign while summing log(|val|)
    #print DEBUG "sum = $sum\n";  # for debugging
  }
  $avg = (1/$N) * $sum;
  #print DEBUG "modified avg = $avg\n";  # for debugging
  $avg = sign($avg) * exp($avg);  # keeping sign and convert log scale to linear scale
  #print DEBUG "exp avg = $avg\n";  # for debugging

  return $avg;
}

# inputs an array ref of data and ouputs the median
sub data_median {
  my $data_ref = $_[0];  # data array reference
  my @data = @{$data_ref};  # de-reference array
  my $N = scalar @data;  # number of items in array
  my @sorted_data = sort{$a <=> $b}(@data);  # 'space ship' operator for numerical sort
  my $med = 0;


  if ($N % 2 == 0){  # even number of elements
  #print DEBUG "even num elements\n";
    $med = ($sorted_data[($N/2)] + $sorted_data[($N/2) -1])/2;
  } else {
    #print DEBUG "odd num elements\n";
    $med = $sorted_data[($N-1)/2];
  }
  return $med;
}

# inputs an array ref of data and outputs the arithmetic avg using tanh
sub tanh_avg {
  my $data_ref = $_[0];  # data array reference
  my @data = @{$data_ref};  # de-reference array
  my $N = scalar @data;  # number of items in array
  my $sum = 0;
  my $eps = 1*(10**(-4));  # target mc energy (parameter) for every condition being averaged

  for $val (@data){
    #print DEBUG "val = $val\n";  # for debugging
    $tanh = tanhx($val/$eps);
    #print DEBUG "tanh x = $tanh \n";
    $sum = $sum + (tanhx($val/$eps));
    #print DEBUG "sum = $sum\n";  # for debugging
  }
  $avg = (1/$N) * $sum;
  #print DEBUG "avg = $avg\n";  # for debugging
  #$avg = arctanhx($avg/$eps);  # convert back to linear scale
  #print DEBUG "converted arctanh avg = $avg\n";  # for debugging

  return $avg;
}


# inputs a number and outputs the number's sign (-1,0, or 1)
sub sign{
  my $num = $_[0];
  if ($num > 0){
    return 1;
  } elsif($num < 0){
    return -1;
  } else {
    return 0;
  }
}

# inputs a number and outputs tanh of that number
sub tanhx{
  my $x = $_[0];
  my $solution = (exp(2*$x) - 1)/(exp(2*$x) + 1);  # simplified exponential form of tanh(x)
  return $solution;
}

# inputs a number and outputs arctanh of that number
sub arctanhx{
  my $x = $_[0];
  my $solution = (1/2)*log(abs((1+$x)/(1-$x)));  # log form of arctanh(x)
  return $solution;
}
